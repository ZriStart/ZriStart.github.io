{"meta":{"title":"那年匆匆-","subtitle":null,"description":null,"author":"执念","url":"https://zristart.github.io"},"pages":[{"title":"archive","date":"2018-05-18T14:50:15.000Z","updated":"2018-05-18T14:50:15.230Z","comments":true,"path":"archive/index.html","permalink":"https://zristart.github.io/archive/index.html","excerpt":"","text":""},{"title":"个人简历","date":"2018-05-18T14:49:50.000Z","updated":"2018-06-18T09:01:19.424Z","comments":true,"path":"about/index.html","permalink":"https://zristart.github.io/about/index.html","excerpt":"","text":"联系方式手机/微信号：1502***575Email：gaomingwei2017@163.com 个人信息 高明伟/男/1993 专科/西安翻译学院工作年限：2年 技 术 博 客 ：https://zristart.github.io Github：https://github.com/gmw-zjw 期望职位：web前端开发工程师 期望薪资：税前月薪7k–8k 期望城市：上海 工作经历上海得帆信息技术有限公司 （2018年2月 ~ 至今） 项目简介:1.百洋医药门户，是针对该集团内部的一套BS架构企业内部管理系统， 集成与企业内部管理及人资资源管理为一体一套系统；2.该项目主要分为两大块，门户主页和流程管理；主页使用angular4写 的，具体流程是使用angularJs写的； 3.首页以展示公司为主，流程管理包括事项进度看板，请销假等 技术栈 AngularJs 西安空白网络科技有限公司 （ 2017年1月 ~ 2017年12月 ）根据psd准确还原html，并兼容低版本浏览器通过jquery实现页面过渡动画解决网站低版本浏览器下的兼容性 技术栈 html javascript css 开源项目React音乐：基于React-create-app 创建 React、react-redux、react-routerAPI 是QQ音乐的，通过jsonp伪装访问，抓取数据使用swiper，实现轮播效果使用react-lazyload 实现 图片懒加载 技能清单1、熟练 HTML5 + CSS 、JavaScript 具有良好的代码书写规范;2、熟练使用Angular/Reactd等;3、熟悉Ionic3，可发开app(兼容ios/android/webapp)；4、熟悉移动布局，响应布局，熟练处理多终端适配兼容问题；5、熟练使用Ajax异步请求通讯技术， 以及JSONP和Axios；6、能独立使用Node组合Express写一些接口；7、了解webpack，能配置webpack打包编译环境会使用git版本管理工具;8、可编写/维护可复用的组建; 自我评价踏实，对待工作认真负责热爱前端技术，不断学习新的知识"},{"title":"calendar","date":"2018-05-18T14:50:36.000Z","updated":"2018-05-18T14:57:04.464Z","comments":true,"path":"calendar/index.html","permalink":"https://zristart.github.io/calendar/index.html","excerpt":"","text":"测试"},{"title":"标签","date":"2018-05-18T14:37:12.000Z","updated":"2018-06-18T09:36:55.100Z","comments":true,"path":"tags/index.html","permalink":"https://zristart.github.io/tags/index.html","excerpt":"","text":"angular"}],"posts":[{"title":"React虚拟DOM浅析","slug":"React虚拟DOM浅析","date":"2018-09-05T03:29:22.000Z","updated":"2018-09-05T08:56:17.087Z","comments":true,"path":"React虚拟DOM浅析.html","link":"","permalink":"https://zristart.github.io/React虚拟DOM浅析.html","excerpt":"","text":"React中采用 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。 传统的Diff算法传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。 如果 React 只是单纯的引入 diff 算法而没有任何的优化改进，那么其效率是远远无法满足前端渲染所要求的性能。 因此，想要将 diff 思想引入 Virtual DOM，就需要设计一种稳定高效的 diff 算法，而 React 做到了！ 实现在React 中，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题，这样的操作太大 diff 策略- tree diff // Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 - component dif // 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 - element diff // 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 tree diffReact 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较. 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较. 123456789101112131415updateChilern: function (nextNestChilderElemt, transaction, context) &#123; updateDepath++ var errThrown = true try &#123; this._updateChilern(nextNestChilderElemt, transaction, context) errorThrown = false &#125; catch (err) &#123; updateDepath -- if (!errorThrown) &#123; clearQueue() &#125; else &#123; processQueue() &#125; &#125;&#125; 我们现在只是得到的同级下的节点，如果节点跨级，那应该怎么做呢？答案是这样的，删除创建的，添加创建，因此 React 官方建议不要进行 DOM 节点跨层级的操作。 component diff如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。 MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。 REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。 12345678910111213141516171819202122232425262728293031323334353637// instfunction equeueInerMarkup (parentInst, markup, toIndex) &#123; updateQueue.push(&#123; parentInst: parentInst, parentNode: null, type: ReactMultiChildUpdateTypes.INSERT_MARKUP, // 插入节点 markupIndex: markupQueue.push(markup) - 1, context: null, fromIndex: null, toIndex: toIndex &#125;)&#125;// movefunction enqueueMove (parentInst, markup, toIndex) &#123; updateQueue.push(&#123; parentInst: parentInst, parentNode: null, type: ReactMultiChildUpdateTypes.MOVE_EXISTING, //移动一节点 markupIndex: null, context: null, fromIndex: fromIndex, toIndex: toIndex &#125;)&#125;//removefunction enqueueRmove (parentInst, fromIndex) &#123; updateQueue.push(&#123; parentInst: parentInst, parentNode: null, type: ReactMultiChildUpdateTypes.REMOVE_NODE, // 移除一节点 context: null, fromIndex: fromIndex, toIndex: null &#125;)&#125; 这样的做法会带来对性能的消耗，这时候react对此提出优化，在进行比较后会对结构相同的组件移动位置，而不是删除/创建的方法，进而大大的提高了性能。 转载于知乎 那么，如此高效的 diff 到底是如何运作的呢？让我们通过源码进行详细分析。 首先对新集合的节点进行循环遍历，for (name in nextChildren)，通过唯一 key 可以判断新老集合中是否存在相同的节点，if (prevChild === nextChild)，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与 lastIndex 进行比较，if (child._mountIndex &lt; lastIndex)，则进行节点移动操作，否则不执行该操作。这是一种顺序优化手段，lastIndex 一直在更新，表示访问过的节点在老集合中最右的位置（即最大的位置），如果新集合中当前访问的节点比 lastIndex 大，说明当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置，因此不用添加到差异队列中，即不执行移动操作，只有当访问的节点比 lastIndex 小时，才需要进行移动操作。 以上图为例，可以更为清晰直观的描述 diff 的差异对比过程： 从新集合中取得 B，判断老集合中存在相同节点 B，通过对比节点位置判断是否进行移动操作，B 在老集合中的位置 B._mountIndex = 1，此时 lastIndex = 0，不满足 child._mountIndex &lt; lastIndex 的条件，因此不对 B 进行移动操作；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，其中 prevChild._mountIndex 表示 B 在老集合中的位置，则 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置prevChild._mountIndex = nextIndex，此时新集合中 B._mountIndex = 0，nextIndex++ 进入下一个节点的判断。 从新集合中取得 A，判断老集合中存在相同节点 A，通过对比节点位置判断是否进行移动操作，A 在老集合中的位置 A._mountIndex = 0，此时 lastIndex = 1，满足 child._mountIndex &lt; lastIndex的条件，因此对 A 进行移动操作enqueueMove(this, child._mountIndex, toIndex)，其中 toIndex 其实就是 nextIndex，表示 A 需要移动到的位置；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 1，并将 A 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中A._mountIndex = 1，nextIndex++ 进入下一个节点的判断。 从新集合中取得 D，判断老集合中存在相同节点 D，通过对比节点位置判断是否进行移动操作，D 在老集合中的位置 D._mountIndex = 3，此时 lastIndex = 1，不满足 child._mountIndex &lt; lastIndex的条件，因此不对 D 进行移动操作；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 3，并将 D 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中D._mountIndex = 2，nextIndex++ 进入下一个节点的判断。 从新集合中取得 C，判断老集合中存在相同节点 C，通过对比节点位置判断是否进行移动操作，C 在老集合中的位置 C._mountIndex = 2，此时 lastIndex = 3，满足 child._mountIndex &lt; lastIndex 的条件，因此对 C 进行移动操作 enqueueMove(this, child._mountIndex, toIndex)；更新 lastIndex = Math.max(prevChild._mountIndex, lastIndex)，则 lastIndex ＝ 3，并将 C 的位置更新为新集合中的位置 prevChild._mountIndex = nextIndex，此时新集合中 C._mountIndex = 3，nextIndex++ 进入下一个节点的判断，由于 C 已经是最后一个节点，因此 diff 到此完成。 以上主要分析新老集合中存在相同节点但位置不同时，对节点进行位置移动的情况，如果新集合中有新加入的节点且老集合存在需要删除的节点，那么 React diff 又是如何对比运作的呢？ 以下图为例： 从新集合中取得 B，判断老集合中存在相同节点 B，由于 B 在老集合中的位置 B._mountIndex = 1，此时lastIndex = 0，因此不对 B 进行移动操作；更新 lastIndex ＝ 1，并将 B 的位置更新为新集合中的位置B._mountIndex = 0，nextIndex++进入下一个节点的判断。 从新集合中取得 E，判断老集合中不存在相同节点 E，则创建新节点 E；更新 lastIndex ＝ 1，并将 E 的位置更新为新集合中的位置，nextIndex++进入下一个节点的判断。 从新集合中取得 C，判断老集合中存在相同节点 C，由于 C 在老集合中的位置C._mountIndex = 2，lastIndex = 1，此时 C._mountIndex &gt; lastIndex，因此不对 C 进行移动操作；更新 lastIndex ＝ 2，并将 C 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。 从新集合中取得 A，判断老集合中存在相同节点 A，由于 A 在老集合中的位置A._mountIndex = 0，lastIndex = 2，此时 A._mountIndex &lt; lastIndex，因此对 A 进行移动操作；更新 lastIndex ＝ 2，并将 A 的位置更新为新集合中的位置，nextIndex++ 进入下一个节点的判断。 当完成新集合中所有节点 diff 时，最后还需要对老集合进行循环遍历，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 D，因此删除节点 D，到此 diff 全部完成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081_updateChildren: function(nextNestedChildrenElements, transaction, context) &#123; var prevChildren = this._renderedChildren; var nextChildren = this._reconcilerUpdateChildren( prevChildren, nextNestedChildrenElements, transaction, context); if (!nextChildren &amp;&amp; !prevChildren) &#123; return; &#125; var name; var lastIndex = 0; var nextIndex = 0; for (name in nextChildren) &#123; if (!nextChildren.hasOwnProperty(name)) &#123; continue; &#125; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var nextChild = nextChildren[name]; if (prevChild === nextChild) &#123; // 移动节点 this.moveChild(prevChild, nextIndex, lastIndex); lastIndex = Math.max(prevChild._mountIndex, lastIndex); prevChild._mountIndex = nextIndex; &#125; else &#123; if (prevChild) &#123; lastIndex = Math.max(prevChild._mountIndex, lastIndex); // 删除节点 this._unmountChild(prevChild); &#125; // 初始化并创建节点 this._mountChildAtIndex( nextChild, nextIndex, transaction, context ); &#125; nextIndex++; &#125; for (name in prevChildren) &#123; if (prevChildren.hasOwnProperty(name) &amp;&amp; !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))) &#123; this._unmountChild(prevChildren[name]); &#125; &#125;this._renderedChildren = nextChildren;&#125;,// 移动节点moveChild: function(child, toIndex, lastIndex) &#123; if (child._mountIndex &lt; lastIndex) &#123; this.prepareToManageChildren(); enqueueMove(this, child._mountIndex, toIndex); &#125;&#125;,// 创建节点createChild: function(child, mountImage) &#123; this.prepareToManageChildren(); enqueueInsertMarkup(this, mountImage, child._mountIndex);&#125;,// 删除节点removeChild: function(child) &#123; this.prepareToManageChildren(); enqueueRemove(this, child._mountIndex);&#125;,_unmountChild: function(child) &#123; this.removeChild(child); child._mountIndex = null;&#125;,_mountChildAtIndex: function( child, index, transaction, context) &#123; var mountImage = ReactReconciler.mountComponent( child, transaction, this, this._nativeContainerInfo, context ); child._mountIndex = index; this.createChild(child, mountImage);&#125;, 本文整理至知乎，如有侵权请联系作者删除！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zristart.github.io/tags/React/"}]},{"title":"“延禧配色”是怎么调出来的？调色总监亲自教你!","slug":"“延禧配色”是怎么调出来的？调色总监亲自教你","date":"2018-09-01T02:21:33.000Z","updated":"2018-09-01T05:37:34.084Z","comments":true,"path":"“延禧配色”是怎么调出来的？调色总监亲自教你.html","link":"","permalink":"https://zristart.github.io/“延禧配色”是怎么调出来的？调色总监亲自教你.html","excerpt":"","text":"随着暑假即将结束《延禧攻略》也落下了帷幕但是电视剧中古朴典雅的色调却一直被大家所津津乐道 今天大大君分享的这篇文章是《延禧攻略》的调色总监孙婷亲自写就的“调色攻略” 关于延禧攻略的色调灵感 整体设计灵感来自于中国国画的绢本设色的画作（绢本：绘在绢、绫、丝织物上的字画。设色：在画作上晕染颜色。）绢本设色的绘画作品，由于是在麦色织物上作画上色，绢本的麦色底色的这一独特元素，造就了中国国画深沉厚重的古朴的质感。 《延禧攻略》时代背景发生在清朝乾隆年间。对于清朝画家，孙婷深爱冷枚的《春闺倦读图》和宫廷画师郎世宁的《午端图》。 （清）冷枚《春闺倦读图》 （清）郎世宁《午端图》 冷枚的《春闺倦读图》中的满族仕女，温婉恬静，妩媚动人。 郎世宁自不用说，本人就是宫廷画师，他把西方的绘画技法运用到工笔画作画上，形成细致逼真的效果，一直深受皇室喜爱。 （清）郎世宁《锦春图》 （清）冷枚《梧桐双兔图》 (清) 郎世宁《雍正十二月圆明园行乐图》 根据绢本画作麦色底所呈现的独特质感，在《延禧攻略》色调创意中加入麦色底色，再根据不同时间，场景，故事，人物设定等对于麦色底浓度色彩偏向进行调整，在保证画面固有色的基础上逐层推进叠加其他色彩加以配比形成如今看到的古画作质感。 这两幅画一人，一物，伴随着绢本厚重的古典气息便成了《延禧攻略》色调最初的灵感……… 关于《延禧攻略》的配色与色彩整合调整 《延禧攻略》本剧前期设定服化道，美术，摄影构图都十分精致，大到场景，人物造型服装，小到配饰道具无不精美考究，带给人一种古色古香的视觉体验。 所以根据本剧的定位后期调色在配色上全部采用中国传统色系。中国传统色系具有一套完整的色彩体系与寓意，几千年来融入古人生活中的衣食住行方方面面，不同的色彩但都有着不约而同的美好名字，且每个颜色都寓意深远，或热烈或悠远，或庄严或张扬，或悲壮或堂皇……色与物相互作比，常常又生出另一道深远美好的光景…… 比如绛红色，白居易写山茶花： 似有浓妆出绛纱，行充一道映彩霞。 杨万里写水红色的荷：接天莲叶无穷碧 ，映日荷花别样红。 《诗经 ·淇奥》用青青绿竹比喻君子： 瞻彼淇奥，绿竹青青。有匪君子，充耳琇莹，会弁如星。 中国色系用自己独特的魅力装点着古人的生活和精神世界 对于古装剧色调制作，一大难点在于各项配色与人物环境是否协调，是否能很好的服务于画面的整体效果。 本次《延禧攻略》色调所采用的中国传统色系最大特点就是以天然植物，动物，矿物作为色彩原料，这样的来自自然界的颜色，色彩范围广又极富生命力，少了工业化学染剂色的呆板锋利，多了一份温润柔和。能更好的将观众带入故事设定发生的时代。 在古装剧具体画面中制作调色则需要将所有呈现工业染剂色彩进修正，改善。使画面中所有色彩在固有色不变的基础上更融入大色调，颜色即富有个性又不至于某种色彩十分出挑抢眼，做到在还原突出质感的基础上又不至杂乱无章。 整体场景画面配色中，调色要服务于剧情设定需要，去除多余杂色，辅助摄影、灯光，根据环境气氛，加强光影效果。感官上使画面更具有冲击力，更好辅助演员表演情绪所展现出的气氛。 同时调色也要根据不同的人物身份性格，对不同人物的住所做了一定的设计。 例如皇帝的养心殿，加入了一些明黄色，彰显皇帝九五至尊的地位。 白月光皇后娘娘的居所长春宫则加入了一些更温暖的杏黄色，表现出皇后娘娘的温柔贤淑. 娴妃前期一心心系皇帝，与世无争，她的承乾宫前期更为清雅，后期她被逼黑化，居所色调中加入一些暖色调，更为沉重，既表现她觊觎后位的野心，也展现她取而代之的决心。 娴妃黑化前期 前期令妃待了很久的绣坊，则加入一些嫣红色表现刚入宫的一群小姑娘充满青春的气息。 画面中出现面积最大的配色便是各位娘娘精致的服装，特别是刺绣运用全三色，显五彩，素五彩，淡单色，雅单色，补色，借色，京绣中艳而不俗的配色等等，都十分精美异常。 绣制在罗，丝，绸，缎等不同质地的衣料上所呈现的质感光泽也不尽相同。调色则需要整合所有刺绣服装色彩让多种不同色彩都很好的融入画面色调中，在不伤害固有色的前提下再次更贴近所使用的中国传统色系，达到深沉古典但不失生命力的感观效果。 例如红色调整为胭脂，绯红等色 蓝色多调整为靛蓝，藏青，绀青等色 绿色多调整为松花绿，绿沈，青碧，豆绿，竹青，黛绿等色 黄色调整为杏黄，缃色，赤金色，黄栌，棕黄等色 不仅仅是对于服装，包括剧中人物妆容色彩，首饰部分的点翠的色泽，绒花，玉器，瓷器，金、银、铜器的光泽质感，瓦砾梁柱，宫墙，漆器等调色都要在保证原有固有色的基础上根据整体色调进行整合调整，使每种色彩都更加发挥出有中国传统色彩的深沉柔和感，更好的服务于画面与故事剧情。 调色在制作剧集过程中，不光要对正戏进行色调创作和制作，调色也要对其他与剧集有关的物料画面进行调整。大家大爱的片头也进行了调整，修正为更具有古画气氛的色调，使其与正戏色调达到呼应统一。 调色作为影视剧不可或缺的二次艺术创作部分，需要把这种二次创作发挥到极致。画面色彩是一部剧最直观的感受，精准细致的色调制作，可以更好的在观感上迅速确立一部剧的定位与气质，为剧锦上添花。 欢迎转载，如有侵权请联系作者删除!","categories":[],"tags":[{"name":"设计","slug":"设计","permalink":"https://zristart.github.io/tags/设计/"}]},{"title":"深入React.js技术栈","slug":"深入React-js技术栈","date":"2018-08-06T15:58:51.000Z","updated":"2018-08-06T15:58:51.318Z","comments":true,"path":"深入React-js技术栈.html","link":"","permalink":"https://zristart.github.io/深入React-js技术栈.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"node事件循环机制","slug":"node事件循环机制","date":"2018-07-24T15:11:02.000Z","updated":"2018-07-24T15:12:39.373Z","comments":true,"path":"node事件循环机制.html","link":"","permalink":"https://zristart.github.io/node事件循环机制.html","excerpt":"","text":"","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zristart.github.io/tags/javascript/"}]},{"title":"Vuex浅析","slug":"Vuex浅析","date":"2018-07-10T03:35:45.000Z","updated":"2018-07-10T03:38:22.803Z","comments":true,"path":"Vuex浅析.html","link":"","permalink":"https://zristart.github.io/Vuex浅析.html","excerpt":"","text":"说到状态管理,我们知道React中的Redux,那么Vue中又有那些优秀的状态管理库呢?当然是Vuex了.","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://zristart.github.io/tags/Vue/"}]},{"title":"Vue生命周期指南","slug":"Vue生命周期指南","date":"2018-07-10T01:30:10.000Z","updated":"2018-07-10T03:34:44.714Z","comments":true,"path":"Vue生命周期指南.html","link":"","permalink":"https://zristart.github.io/Vue生命周期指南.html","excerpt":"","text":"最近开始学Vue,怎么学呢？从开始阅读官方文档开始吧，不得不说Vue官方文档写的真心不错,现在就让我们开始走进今天的Vue生命周期函数吧。 这是我个人Vue生命周期函数的总结，由于本人技术尚浅，哪里错误还请多多指出。 breforeCreatecreatedbeforeMount // 进行初始化事件数据初始化，我么可以看到created已经和data数据绑定上了; –&gt; 首先会判断对象是否有el选项,如果有继续向下编译，如果没有则会停止编译,Vue的生命周期也就到此终结了。 –&gt; 如果我们注释上面的el: ‘app’这段代码的话,Vue的生命周期也就到此结束了,说明这块是Vue初始化DOM的入口点；也就是DOM的挂在点 –&gt; 如果我们继续调用vm.$mount(el),Vue生命周期将会继续向下执行. 现在有一个问题，我们在生命周期函数中渲染template模板,会不会影响代码的加载时间呢？请看该代码片段:1234567891011121314const vm = new Vue(&#123; // el: 挂载点 el: '#app', template: '&lt;h1&gt;&#123;&#123;message + \" 这是模板代码片段 \" &#125;&#125;&lt;/h1&gt;', data: &#123; return&#123; message: '我是vue生命周期' &#125; &#125;, created: &#123; console.log(' create init '); &#125;, // ...&#125;) 想想上面这段代码会怎么执行呢？是这样的,vue生命周期函数中,首先会寻找挂载点也就是el元素，挂载到DOM，整个Vue生命周期开始 beforeMount和mounted分别有做了那些动作呢?组件元素渲染,这时候数据已经挂载到DOM上了。 breforeUpdate 和 update更新data里面的数据,渲染DOM beeforeDestroy和Destory这是Vue生命周期的最后阶段,一般我们会再这里去销毁组件,值得注意的是在brefore中我们还是可以正常组件实例的;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://zristart.github.io/tags/Vue/"}]},{"title":"React中事件this的绑定方式","slug":"React中事件this的绑定方式","date":"2018-07-03T03:27:57.000Z","updated":"2018-07-03T03:49:27.692Z","comments":true,"path":"React中事件this的绑定方式.html","link":"","permalink":"https://zristart.github.io/React中事件this的绑定方式.html","excerpt":"","text":"在React中创建事件，绑定this时长发生，那this是如何进行绑定的呢？ 1、一般情况下我们会把this绑定在构造函数中12345678910111213controuctor() &#123; super(); let handleDefault = this.handleDefault.bind(this);&#125;render() &#123; return ( &lt;div&gt; &lt;a href=&quot;#&quot; onClick=&#123;this.handleDefault&#125;&gt;&lt;/a&gt; &lt;/div&gt; );&#125; 这样做的好处在于，我们可以清晰的看到当前组件中的事件到底有哪些，对于性能优化也存在一定的好处 2、另一种情况我们会在事件上 绑定this,例如下面的代码:123456789...render() &#123; return ( &lt;div&gt; &lt;a href=&quot;#&quot; onClick=&#123;&#123;this.handleClick().bind(this)&#125;&#125;&gt;&lt;/a&gt; &lt;/div&gt; );&#125;... 3、再者就是利用箭头函数进行绑定1234567891011...handleCilick = () =&gt; &#123; // coding ...&#125;...render() &#123; renturn( &lt;a href=&quot;#&quot; onClick=&#123;(e) =&gt; this.handleClink(e)&#125;&gt;&lt;/a&gt; );&#125; 事件传参12345678910handleClick (e, id) =&gt; &#123; // coding ...&#125;render() &#123; return( &lt;a href=&quot;#&quot; onClick=&#123;(e) =&gt; this.handleClick(id, e)&#125;&gt;Cliclk Me&lt;/a&gt; &lt;a href=&quot;#&quot; onClick=&#123;this.handleClick.bind(this, id)&#125;&gt;Cliclk Me&lt;/a&gt; );&#125; 上面这两者是等价的;拿官方上面的一句话说明:值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面123456789101112131415161718192021class Popper extends React.Component&#123; constructor()&#123; super(); this.state = &#123;name:&apos;Hello world!&apos;&#125;; &#125; preventPop(name, e)&#123; //事件对象e要放在最后 e.preventDefault(); alert(name); &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &#123;/* Pass params via bind() method. */&#125; &lt;a href=&quot;https://reactjs.org&quot; onClick=&#123;this.preventPop.bind(this,this.state.name)&#125;&gt;Click&lt;/a&gt; &lt;/div&gt; ); &#125;&#125;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zristart.github.io/tags/React/"}]},{"title":"React组件生命周期函数","slug":"React组件生命周期函数","date":"2018-07-03T01:59:00.000Z","updated":"2018-07-03T03:03:27.344Z","comments":true,"path":"React组件生命周期函数.html","link":"","permalink":"https://zristart.github.io/React组件生命周期函数.html","excerpt":"","text":"按照执行顺序依次如下:1234567891011121314constructor()&#123;&#125;// 组件初始化时调用，只会调用一次componentWillMount()&#123;&#125;// 组件初始化时调用，一般我们会在此调用ajax等componentDidMount() &#123;&#125;// 父组件更新时调用componentReceiveProps()&#123;&#125;// 组件更新时shouldComponendUpdate() &#123;&#125;// render 之后执行componentWillUpdate() &#123;&#125;componentDidUpdate() &#123;&#125;// 最后执行,用于销毁定时器，事件监听等操作componentWillUnmount() &#123;&#125; 更新方式: 1、首次渲染Initial Render2、调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）3、父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）4、调用this.forceUpdate","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zristart.github.io/tags/React/"}]},{"title":"清除浮动有几种方式，优缺点分别是什么","slug":"清除浮动有几种方式，优缺点分别是什么","date":"2018-07-02T15:40:27.000Z","updated":"2018-07-02T15:48:11.166Z","comments":true,"path":"清除浮动有几种方式，优缺点分别是什么.html","link":"","permalink":"https://zristart.github.io/清除浮动有几种方式，优缺点分别是什么.html","excerpt":"","text":"一、 在浮动元素后加一个空的元素, 设置clear:both; 让父元素自动获取高度； 优点: 简单、代码少，浏览器支持好，不容易出现怪问题 缺点: 增加了空标签，会影响浏览器的解析速度 123456789&lt;div&gt; &lt;div class='fl'&gt;左浮动&lt;/div&gt; &lt;div class='fr'&gt;右浮动&lt;/div&gt; &lt;div class='clear'&gt;&lt;/div&gt;&lt;/div&gt;/*********CSS代码**********/.fl&#123;float:left;&#125;.fr&#123;float:right;&#125;.clear&#123;clear:both;&#125; 二、给设置浮动的元素的父级元素添加overflow CSS属性，属性设置为hidden或者auto1234567891011121314&lt;!-----HTML代码----&gt;&lt;div class=&apos;clear&apos; &gt;&lt;div class=&apos;fl&apos;&gt;左浮动&lt;/div&gt;&lt;div class=&apos;fr&apos;&gt;右浮动&lt;/div&gt;&lt;/div&gt;/***********CSS代码***********/.fl&#123;float:left;&#125;.fr&#123;float:right;&#125;.clear&#123;overflow:hidden;zoom:1; /*兼容IE浏览器*/&#125;/***.clear&#123;overflow:auto;&#125;****/ 优点：代码少，容易上手，浏览器支持好缺点：不能和position属性配合使用。同时使用position会出现以下情况：如果是使用hidden清除浮动，超出的部分会被隐藏；如果使用auto清除浮动，子元素的尺寸过大时会出现滚动条 三、使用为元素:after来清除浮动，如右边案例所示，表示在clear类的div元素后插入内容，并设置该内容的样式 12345678910111213141516171819&lt;div class=&apos;clear&apos; &gt;&lt;div class=&apos;fl&apos;&gt;左浮动&lt;/div&gt;&lt;div class=&apos;fr&apos;&gt;右浮动&lt;/div&gt;&lt;/div&gt;/***********CSS代码***********/.fl&#123;float:left;&#125;.fr&#123;float:right;&#125;.clear:after&#123;content:&apos;.&apos;;display:disblock;width:0;height:0;visibility:hidden;clear:both;&#125;.clear&#123;zoom:1; /*兼容IE浏览器,触发hasLayout*/&#125; 优点：浏览器支持好，不容易出现一些意想不到的问题，大型网站如新浪、网易等都有使用这个方法缺点：代码较多，初学者相对其他方式不容易掌握 四、float-in-float，将父级元素和子元素都设置浮动，并在与父级元素同级的下一个相邻元素中设置clear:both;12345678910111213141516&lt;!-----HTML代码----&gt;&lt;div class=&apos;clear&apos; &gt;&lt;div class=&apos;fl&apos;&gt;左浮动&lt;/div&gt;&lt;div class=&apos;fr&apos;&gt;右浮动&lt;/div&gt;&lt;/div&gt;&lt;div class=&apos;cnt&apos;&gt;content&lt;/div&gt;/***********CSS代码***********/.fl&#123;float:left;&#125;.fr&#123;float:right;&#125;.clear&#123;float:left;&#125;.cnt&#123;clear:both;&#125; 缺点：可能会出现新的浮动问题","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://zristart.github.io/tags/css/"}]},{"title":"React的setState之后都做了那些事","slug":"React的setState之后都做了那些事","date":"2018-07-02T15:21:41.000Z","updated":"2018-07-02T15:33:36.173Z","comments":true,"path":"React的setState之后都做了那些事.html","link":"","permalink":"https://zristart.github.io/React的setState之后都做了那些事.html","excerpt":"","text":"1.执行setState()之后干了什么？ setState()方法通过一个队列机制实现state更新，当执行setState()的时候，会将需要更新的state合并之后放入状态队列，而不会立即更新this.state(可以和浏览器的事件队列类比)。如果我们不使用setState而是使用this.state.key来修改，将不会触发组件的re-render。如果将this.state赋值给一个新的对象引用，那么其他不在对象上的state将不会被放入状态队列中，当下次调用setState()并对状态队列进行合并时，直接造成了state丢失。 2.setState()可以接受一个函数作为参数？ setState() 不仅能够接受一个对象作为参数，还能够接受一个函数作为参数。函数的参数即为 state 的前一个状态以及 props。1234void setState ( function|object nextState, [function callback]) 上述代码的第二个参数是一个回调函数，在setState() 的异步操作结束并且组件已经重新渲染的时候执行。换句话说，我们可以通过这个回调来拿到更新的state的值。 3.执行setState()后能拿到最新的state值吗？ 以前在写代码时候，总是遇到明明执行过setState()，但是state的值却不是最新的，那么如何解决这个问题呢？ 因为setState()函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，是在设置状态成功之后执行的，所以我们可以通过回掉拿到最新的state值。代码如下： 123456789updateData = (newData) =&gt; &#123; this.setState( &#123; data: newData &#125;, () =&gt; &#123; //这里打印的是最新的state值 console.log(that.state.data); &#125; );&#125; 4.setState()一定是异步更新吗？原文链接12345function incrementMultiple() &#123; this.setState(&#123;count: this.state.count + 1&#125;); this.setState(&#123;count: this.state.count + 1&#125;); this.setState(&#123;count: this.state.count + 1&#125;);&#125; 直观上来看，当上面的 incrementMultiple 函数被调用时，组件状态的 count 值被增加了3次，每次增加1，那最后 count 被增加了3。但是，实际上的结果只给 state 增加了1。事实上，setState 方法与包含在其中的执行是一个很复杂的过程，从 React 最初的版本到现在，也有无数次的修改。它的工作除了要更动 this.state 之外，还要负责触发重新渲染，这里面要经过 React 核心 diff 算法，最终才能决定是否要进行重渲染，以及如何渲染。而且为了批次与效能的理由，多个 setState 呼叫有可能在执行过程中还需要被合并，所以它被设计以延时的来进行执行是相当合理的。 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。 由 React 控制的事件处理过程 setState 不会同步更新 this.state！也就是说，在 React 控制之外的情况， setState 会同步更新 this.state！ 但大部份的使用情况下，我们都是使用了 React 库中的表单组件，例如 select、input、button 等等，它们都是 React 库中人造的组件与事件，是处于 React库的控制之下，比如组件原色 onClick 都是经过 React 包装。在这个情况下，setState 就会以异步的方式执行。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zristart.github.io/tags/React/"}]},{"title":"事件冒泡和如何阻止事件冒泡","slug":"事件冒泡和如何阻止事件冒泡","date":"2018-07-02T15:09:40.000Z","updated":"2018-07-02T15:18:43.682Z","comments":true,"path":"事件冒泡和如何阻止事件冒泡.html","link":"","permalink":"https://zristart.github.io/事件冒泡和如何阻止事件冒泡.html","excerpt":"","text":"首先请看如下代码:12345678910111213&lt;span style=&quot;font-family:Microsoft YaHei;font-size:10px;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123;document.getElementById(&quot;box1&quot;).addEventListener(&quot;click&quot;,function(event)&#123;alert(&quot;您好，我是最外层div。&quot;);&#125;);document.getElementById(&quot;box2&quot;).addEventListener(&quot;click&quot;,function(event)&#123;alert(&quot;您好，我是内层div。&quot;);&#125;);document.getElementById(&quot;span&quot;).addEventListener(&quot;click&quot;,function(event)&#123;alert(&quot;没错，我就是span。&quot;);&#125;);&#125;&lt;/script&gt;&lt;/span&gt; 预期上述代码会单击span 的时候，会出来一个弹出框 “没错，我就是span。” 是的，确实弹出了这样的对话框然而，不仅仅会产生这个对话框，当点击确定后，会依次弹出其他对话框. 解决方案: 方法一：我们来考虑一个形象一点的情况：水中的一个气泡正在从底部往上冒，而你现在在水中，不想让这个气泡往上冒，怎么办呢？你首先想到的肯定就是把它扎破，扎破了自然就不会往上冒了。类似地，对某一个节点而言，如果不想它现在处理的事件继续往上冒泡的话，我们可以终止冒泡。加入 event.stopPropagation():12345678910111213141516&lt;span style=&quot;font-family:Microsoft YaHei;font-size:10px;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123;document.getElementById(&quot;box1&quot;).addEventListener(&quot;click&quot;,function(event)&#123;alert(&quot;您好，我是最外层div。&quot;);event.stopPropagation();&#125;);document.getElementById(&quot;box2&quot;).addEventListener(&quot;click&quot;,function(event)&#123;alert(&quot;您好，我是内层div。&quot;);event.stopPropagation();&#125;);document.getElementById(&quot;span&quot;).addEventListener(&quot;click&quot;,function(event)&#123;alert(&quot;没错，我就是span。&quot;);event.stopPropagation();&#125;);&#125;&lt;/script&gt;&lt;/span&gt; 方法二:事件包含最初触发事件的节点引用 和 当前处理事件节点的引用，那如果节点只处理自己触发的事件即可,不是自己产生的事件不处理。 event.target 引用了产生此event对象的dom 节点，而event.currrentTarget 则引用了当前处理节点，我们可以 两个target 是否相等 比如span 点击事件，产生一个event 事件对象，event.target 指向了span元素，span处理此事件时，event.currentTarget指向的也是span元素，这时判断两者相等，则执行相应的处理函数。而事件传递给div2 的时候，event.currentTarget变成 div2，这时候判断二者不相等，即事件不是div2 本身产生的，就不作响应处理逻辑。1234567891011121314151617181920212223方法二&lt;span style=&quot;font-family:Microsoft YaHei;font-size:10px;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;window.onload = function() &#123;document.getElementById(&quot;box1&quot;).addEventListener(&quot;click&quot;,function(event)&#123;if(event.target == event.currentTarget)&#123;alert(&quot;您好，我是最外层div。&quot;);&#125;&#125;);document.getElementById(&quot;box2&quot;).addEventListener(&quot;click&quot;,function(event)&#123;if(event.target == event.currentTarget)&#123;alert(&quot;您好，我是内层div。&quot;);&#125;&#125;);document.getElementById(&quot;span&quot;).addEventListener(&quot;click&quot;,function(event)&#123;if(event.target == event.currentTarget)&#123;alert(&quot;没错，我就是span。&quot;);&#125;&#125;);&#125;&lt;/script&gt;&lt;/span&gt; 优缺点： 方法一缺点：为了实现点击特定的元素显示对应的信息，方法一要求每个元素的子元素也必须终止事件的冒泡传递，即跟别的元素功能上强关联，这样的方法会很脆弱。比如，如果span 元素的处理函数没有执行冒泡终止，则事件会传到div2上，这样会造成div2 的提示信息； 方法二缺点：方法二为每一个元素都增加了事件监听处理函数，事件的处理逻辑都很相似，即都有判断 if(event.target == event.currentTarget)，这样存在了很大的代码冗余，现在是三个元素还好，当有10几个，上百个又该怎么办呢？还有就是为每一个元素都有处理函数，在一定程度上增加逻辑和代码的复杂度。 既然事件是冒泡传递的，那可不可以让某个父节点统一处理事件，通过判断事件的发生地（即事件产生的节点），然后做出相应的处理呢？答案是可以的，下面通过给body 元素添加事件监听，然后通过判断event.targe然后对不同的target产生不同的行为 重构方法二的代码:123456789101112131415161718&lt;script type=&quot;text/javascript&quot;&gt; window.onload = function() &#123; document.getElementById(&quot;body&quot;).addEventListener(&quot;click&quot;,eventPerformed); &#125;; function eventPerformed(event) &#123; var target = event.target; switch (target.id) &#123; case &quot;span&quot;: alert(&quot;没错，我就是传说中的span。&quot;); break; case &quot;box1&quot;: alert(&quot;您好，我是最外层div。&quot;); break; case &quot;box2&quot;: alert(&quot;您好，我是内层div。&quot;); break; &#125; &#125; 事件冒泡有什么作用？ 事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zristart.github.io/tags/javascript/"}]},{"title":"call和apply的区别以及他们的用法","slug":"call和apply的区别以及他们的用法-1","date":"2018-07-02T15:08:44.000Z","updated":"2018-07-02T15:08:44.784Z","comments":true,"path":"call和apply的区别以及他们的用法-1.html","link":"","permalink":"https://zristart.github.io/call和apply的区别以及他们的用法-1.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"call和apply的区别以及他们的用法","slug":"call和apply的区别以及他们的用法","date":"2018-07-02T15:08:14.000Z","updated":"2018-07-02T15:09:06.538Z","comments":true,"path":"call和apply的区别以及他们的用法.html","link":"","permalink":"https://zristart.github.io/call和apply的区别以及他们的用法.html","excerpt":"","text":"call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下：var func1 = function(arg1, arg2) {};就可以通过 func1.call(this, arg1, arg2);或者 func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zristart.github.io/tags/javascript/"}]},{"title":"javacript原型原型链继承","slug":"javacript原型原型链继承","date":"2018-06-24T12:26:52.000Z","updated":"2018-06-24T12:26:52.940Z","comments":true,"path":"javacript原型原型链继承.html","link":"","permalink":"https://zristart.github.io/javacript原型原型链继承.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Angular4 表单验证","slug":"Angular4-表单验证","date":"2018-06-23T14:30:08.000Z","updated":"2018-06-23T14:30:09.393Z","comments":true,"path":"Angular4-表单验证.html","link":"","permalink":"https://zristart.github.io/Angular4-表单验证.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"前端性能优化有哪些","slug":"前端性能优化有哪些","date":"2018-06-23T11:02:29.000Z","updated":"2018-06-23T11:02:30.027Z","comments":true,"path":"前端性能优化有哪些.html","link":"","permalink":"https://zristart.github.io/前端性能优化有哪些.html","excerpt":"","text":"","categories":[],"tags":[]},{"title":"git","slug":"git","date":"2018-06-23T10:48:02.000Z","updated":"2018-06-23T10:56:33.502Z","comments":true,"path":"git.html","link":"","permalink":"https://zristart.github.io/git.html","excerpt":"","text":"1.git.fetch和merge和pull的区别 pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。 git fetch：相当于是从远程获取最新版本到本地，不会自动merge git merge : 将内容合并到当前分支 git pull：相当于是从远程获取最新版本并merge到本地 tag tag指向一次commit的id，通常用来给开发分支做一个标记打标签 : git tag -a v1.01 -m “Relase version 1.01”提交标签到远程仓库 : git push origin –tags查看标签 : git tag查看某两次tag之间的commit：git log –pretty=oneline tagA..tagB查看某次tag之后的commit: git log –pretty=oneline tagA.. Git和SVN的区别 Git是分布式版本控制系统，SVN是集中式版本控制系统 4.Git工作流程 在工作目录中修改某些文件 对修改后的文件进行快照，然后保存到暂存区域 提交更新，将保存在暂存区域的文件快照永久转储到Git目录中 常用命令 git show # 显示某次提交的内容 git show $id git add # 将工作文件修改提交到本地暂存区 git rm # 从版本库中删除文件 git reset # 从暂存区恢复到工作文件 git reset HEAD^ # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git diff # 比较当前文件和暂存区文件差异 git diff git log -p # 查看每次详细修改内容的diff git branch -r # 查看远程分支 git merge # 将branch分支合并到当前分支 git stash # 暂存 git stash pop #恢复最近一次的暂存 git pull # 抓取远程仓库所有分支更新并合并到本地 git push origin master # 将本地主分支推到远程主分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://zristart.github.io/tags/git/"}]},{"title":"Promise","slug":"Promise","date":"2018-06-23T09:43:16.000Z","updated":"2018-06-23T10:28:31.236Z","comments":true,"path":"Promise.html","link":"","permalink":"https://zristart.github.io/Promise.html","excerpt":"","text":"Promise 对象是ES6新增的对象，她得作用是网络请求，是异步编程的一种解决方案。 12345678910111213let promise = new Promise((reslove, reject) =&gt; &#123; if (resolve) &#123; // resolve &#125; else &#123; // reject &#125;&#125;);promise.then((v) =&gt; &#123; // success&#125;, error =&gt; &#123; // error&#125;) 案例(面试题): 怎么解决回调函数里面回调另一个函数，另一个函数的参数需要依赖这个回调函数。需要被解决的代码如下：12345678910111213141516171819202122$http.get(url).success((res) =&gt; &#123; if (success != res) &#123; success(res); &#125;&#125;).error((res) =&gt; &#123; if (error != undefined ) &#123; error(res) &#125;&#125;)success = (data) =&gt; &#123; if (data.id !=0 ) &#123; var url = &quot;getdata/data?id=&quot; + data.id + &quot;&quot;; $http.get(url).success(function (res) &#123; showData(res); &#125;).error(function (res) &#123; if (error != undefined) &#123; error(res); &#125; &#125;); &#125;&#125; 请问下面代码一次输出什么？ 12345678910111213setTimeout(function () &#123; console.log(1)&#125;, 0);new Promise(function executor(resolve) &#123; console.log(2); for (var i = 0; i &lt; 10000; i++) &#123; i == 9999 &amp;&amp; resolve(); &#125; console.log(3);&#125;).then(function () &#123; console.log(4);&#125;);console.log(5); // 2、3、5、4、1// 首先定时器会最后执行,Promise是一个异步对象，会先执行所以会输出 2、3 ,// 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中,// 因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。 promise只有2个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？ 使用promise.all() // Promise.all方法的参数可以不是数组,但必须具有Iterator接口，且返回的每个成员都是Promise实例 Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 分析下面这段代码，会输出什么内容::12345678910111213141516const promise1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;success&apos;) &#125;, 1000)&#125;)const promise2 = promise1.then(() =&gt; &#123; throw new Error(&apos;error!!!&apos;)&#125;)console.log(&apos;promise1&apos;, promise1)console.log(&apos;promise2&apos;, promise2)setTimeout(() =&gt; &#123; console.log(&apos;promise1&apos;, promise1) console.log(&apos;promise2&apos;, promise2)&#125;, 2000) 运行结果：123456789promise1 Promise &#123; &lt;pending&gt; &#125;promise2 Promise &#123; &lt;pending&gt; &#125;(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.promise1 Promise &#123; &apos;success&apos; &#125;promise2 Promise &#123; &lt;rejected&gt; Error: error!!! at promise.then (...) at &lt;anonymous&gt; &#125; 原因：promise 有 3 种状态：pending（进行中）、fulfilled（已完成，又称为Resolved） 或 rejected（已失败）。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zristart.github.io/tags/javascript/"}]},{"title":"Angular-cli常用命令","slug":"Angular-cli常用命令","date":"2018-06-23T04:09:53.000Z","updated":"2018-06-23T04:28:27.318Z","comments":true,"path":"Angular-cli常用命令.html","link":"","permalink":"https://zristart.github.io/Angular-cli常用命令.html","excerpt":"","text":"angular/cli 常用命令: - ng server // 启动服务 - ng g component // 创建组件 - ng g pipe // 创建管道 - ng g service // 创建服务 - ng g directive // 创建指令 - ng build // 编译打包 参数: - --flat // 不在自用的目录内创建代码 - --route=&lt;route&gt; // 指定父路由.仅用于生成组件和路由.默认为指定的路径 - --skip-router-generation // 跳过生成父路由配置。只能用于路由命令。 - --defasult // 指定路由应为默认路由。 - lazy // 指定路由是延迟的。 默认为true。 生产构建 - ng build --target=production --environment=prod - ng build --prod --env=prod - ng build --pr 开发构建 - ng build --target=development --environment=dev - ng build --dev --e=dev - ng build --dev - ng build 自定义指定启动端口号和地址 - ng serve --host 0.0.0.0 --port 4201 --live-reload-port 49153","categories":[],"tags":[{"name":"angular-cli","slug":"angular-cli","permalink":"https://zristart.github.io/tags/angular-cli/"}]},{"title":"创建一个原生的Ajax与jsonp封装的Ajax","slug":"创建一个原生的Ajax与jsonp封装的Ajax","date":"2018-06-22T01:33:08.000Z","updated":"2018-06-22T01:48:07.130Z","comments":true,"path":"创建一个原生的Ajax与jsonp封装的Ajax.html","link":"","permalink":"https://zristart.github.io/创建一个原生的Ajax与jsonp封装的Ajax.html","excerpt":"","text":"原生: 首先我们要知道什么是Ajax，以及如何创建一个Ajax和他是怎样调用服务的？ 创建XMLHTTPRequest 对象 创建一个新的http对象，并指定请求方法类型、验证信息 设置HTTP请求状态变化的回调函数 发送http请求 获取异步调用返回的数据 使用javascript和DOM实现局部刷新 123456789let xhr = new XMLHttpRequest();xhr.open(&quot;POST&quot;, url, true);xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;)xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) &#123; fn.call(this.xhr.responseText); &#125;; xhr.send(data);&#125; jsonp: 实现资源跨域访问请求数据","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://zristart.github.io/tags/Ajax/"}]},{"title":"HTML5新特性总结","slug":"HTML5新特性总结","date":"2018-06-22T01:16:40.000Z","updated":"2018-06-22T01:24:10.316Z","comments":true,"path":"HTML5新特性总结.html","link":"","permalink":"https://zristart.github.io/HTML5新特性总结.html","excerpt":"","text":"本地存储 localStorage sessionStorage离线应用 mainfest桌面通知 Notifications语义化标签 section header nav footer地理位置 Geolocation多任务 webworker跨域资源(CORS)绘画 Canvas拖拽释放(Dray and drop)API媒体 (video) (audio)双工程通讯协议(webscoket)","categories":[],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://zristart.github.io/tags/HTML5/"}]},{"title":"浏览器多个标签之间通讯","slug":"浏览器多个标签之间通讯","date":"2018-06-21T15:25:48.000Z","updated":"2018-06-21T15:44:03.790Z","comments":true,"path":"浏览器多个标签之间通讯.html","link":"","permalink":"https://zristart.github.io/浏览器多个标签之间通讯.html","excerpt":"","text":"第一种: 在一个标签中使用localStorage.setItem(key,value)//添加内容在另一个标签里监听storage事件及可得到 localStorge存储的值，实现不同标签只见那的通讯 标签一:12345678910&lt;input id=&quot;name&quot;&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;&lt;srcipt&gt; $(function () &#123; $(&apos;#btn&apos;).click(function() &#123; var name = $(&apos;#name&apos;).val(); locastorage.setItem(&apos;name&apos;: name); &#125;) &#125;)&lt;/script&gt; 标签二:1234567&lt;script&gt; $(function() &#123; window.addEventListener(&apos;storage&apos;, function(e) &#123; console.log(e.key + e.newVlaue); &#125;); &#125;)&lt;/script&gt; 第二种: 页面一:1234567891011&lt;input id=&quot;name&quot;&gt;&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;提交&quot;&gt;&lt;script&gt; $(function() &#123; $(&apos;#btn&apos;).click(function() &#123; var name = $(&apos;#name&apos;).val(); document.cookie = &apos;name&apos;+name; &#125;); &#125;)&lt;/script&gt; 页面二: 1234567891011&lt;script&gt; $(function() &#123; function getCookie(key) &#123; return JSON.parse(&quot;&#123;\\&quot;&quot; + document.cookie.replace(/;\\s+/gim,&quot;\\&quot;,\\&quot;&quot;).replace(/=/gim, &quot;\\&quot;:\\&quot;&quot;) + &quot;\\&quot;&#125;&quot;)[key] &#125; setInterval(function() &#123; console.log(&apos;name=&apos;+getCookie(&apos;name&apos;)); &#125;, 1000) &#125;)&lt;/script&gt;","categories":[],"tags":[{"name":"cookies localStorag","slug":"cookies-localStorag","permalink":"https://zristart.github.io/tags/cookies-localStorag/"}]},{"title":"Angular4组件之间的传值","slug":"Angular4组件之间的传值","date":"2018-06-21T08:44:09.000Z","updated":"2018-06-21T15:26:59.298Z","comments":true,"path":"Angular4组件之间的传值.html","link":"","permalink":"https://zristart.github.io/Angular4组件之间的传值.html","excerpt":"","text":"组件之间传值 通过Input、Output","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular4生命周期函数","slug":"angular4生命周期函数","date":"2018-06-21T06:44:17.000Z","updated":"2018-06-21T07:12:36.266Z","comments":true,"path":"angular4生命周期函数.html","link":"","permalink":"https://zristart.github.io/angular4生命周期函数.html","excerpt":"","text":"今天去面试，被问到angular4的生命周期函数，自己明明知道的，瞬间脑子一片空白 …. 现在总结如下: ngOnInit 组件初始化时后调用,只会调用一次(在第一次ngOnChanges后调用) ngOnChanges 在有输入属性的情况下才会被调用 ngDoCheck 在组件定义的属性或方法变更时调用,用于脏值之间的检测，由于非常消耗性能，(他会把所有的属性和方法都检测一遍)， 他会在ngChanges,ngOninit后执行 ngAfterContentInit 组件内容初始化之后调用，第一次ngDeCheck之后调用，只会调用一次 ngAfterContentChecked 在组件每次检查内容发生变更时调用，在ngAfterContentInit和每次ngDoCheck之后调用 ngAfterViewInit 在组件相对应的视图初始化之后调用，在ngAfterConetntCheck之后调用,只会调用一次 ngAfterViewChecked 组件每次检查视图初始化之后调用 ngOnDestroy 最后执行,做一些销毁、清理工作(比如说清理清理定时器，移除事件监听，事件退订) 吸取经验教训,总结…","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular4 Output","slug":"angular4-Output","date":"2018-06-19T03:12:58.000Z","updated":"2018-06-19T07:23:06.092Z","comments":true,"path":"angular4-Output.html","link":"","permalink":"https://zristart.github.io/angular4-Output.html","excerpt":"","text":"angular输出属性output 123456789101112131415161718192021222324import &#123; Component, Input, Output, EventEmitter &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;zn-counter&apos;&#125;)export class CounterComponent &#123; constructor ()&#123; &#125; @Input () count: number: 0; @Output() change: EventEmintter&lt;number&gt; = new EventEmintter&lt;number&gt;(); icrement() &#123; this.count ++; this.change.emit(this.count); &#125; decrement() &#123; this.count --; this.change.emint(this.count); &#125;&#125;","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular知识总结","slug":"angular知识总结","date":"2018-06-19T02:05:36.000Z","updated":"2018-06-19T02:51:12.133Z","comments":true,"path":"angular知识总结.html","link":"","permalink":"https://zristart.github.io/angular知识总结.html","excerpt":"","text":"1、angular 是mvc还是mvvm框架 ？ 答案是肯定的. 首先我们来说说什么是mvc，它是由视图、控制器、数据，三者所组成的，mvvm是对mvc的进一步升级，把Controller的数据和逻辑处理部分从中抽离出来， 用一个专门的对象去管理，这个对象就是ViewModel，是Model和Controller之间的一座桥梁。 优点: 1.Controller清晰简洁： ViewModel分离了大部分Controller代码，更加清晰和容易维护。 2.方便测试：开发中大部分Bug来至于逻辑处理，由于ViewModel分离了许多逻辑，可以对ViewModel构造单元测试。 3.开发解耦(举两个例子)： a.一人负责逻辑实现、另一人负责UI实现； b.敏捷开发时，会发经常发不是等后端做好了接口我们再去开发，不过在没有接口的情况下通常我们可以把Controller和View完成。 缺点: 1.看起来代码会比MVC多点 2.需要对每个Controller实现绑定，如果处理不好，反而会有一种“画虎不成反类犬”的感觉","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular4输入属性(Input)","slug":"angular4输入属性-Input","date":"2018-06-18T09:44:13.000Z","updated":"2018-06-18T13:39:10.992Z","comments":true,"path":"angular4输入属性-Input.html","link":"","permalink":"https://zristart.github.io/angular4输入属性-Input.html","excerpt":"","text":"Input 是输入属性,用来定义组件的内的输入属性，主要用来实现父组件想子组件传递数据 123456789101112131415161718192021222324252627import &#123; Component, Input &#125; from &quot;@angular/core&quot;;@Component(&#123; selector: &apos;dex-counter&apos;&#125;)export class CounterComponent &#123; // 变量 _count: number = 0; biggerThanTen: boolean = false; constrcutor() &#123; &#125; // @Input(&apos;value&apos;) count: number = 0; // set @Input() set count(num: number) &#123; this.biggerThanTen = num &gt; 10; this._count = num; &#125; get count():number &#123; return this._count; &#125;&#125; ngOnChanges","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular4中ngOnInit与contrutor的用法详解","slug":"angular4中ngOnInit与contrutor的用法详解","date":"2018-06-18T09:13:49.000Z","updated":"2018-06-18T09:34:18.985Z","comments":true,"path":"angular4中ngOnInit与contrutor的用法详解.html","link":"","permalink":"https://zristart.github.io/angular4中ngOnInit与contrutor的用法详解.html","excerpt":"","text":"想必大家都不陌生constructor构造函数,这是ES6中引入的在angulaur中constructor一般的作用，我们会再其中依赖注入,初始化默认值等操作。 ngOnInit ngOnInit 用于在 Angular 获取输入属性后初始化组件，该钩子方法会在第一次 ngOnChanges 之后被调用 注意: 该钩子只会被调用一次. parent.component.ts 1234567891011121314151617 import &#123; Component &#125; from &quot;@angular/core&quot;; @Component(&#123; selector: &apos;exe-parent&apos;&#125;)export class ParentComponent &#123; private name: &apos;&apos;; constructor() &#123; this.name = &apos;LiMing&apos;; &#125; ngOnInit() &#123; &#125;&#125; child.component.ts 1234567891011121314151617import &#123; Component, Input, OnInit &#125; from &quot;@angular/core&quot;;@Component(&#123; selector: &apos;exe-child&apos;&#125;)export class ChildComponent implements OnInit &#123; @Input() pname: string; // 父组件的名称 constructor() &#123; console.log(&apos;constructor \\&apos; + this.pname) // undefined &#125; ngOnInit () &#123; console.log(&apos;ngOnInit \\&apos; + this.pname) // LiMing &#125;&#125; 我们发现在 ChildComponent 构造函数中，是无法获取输入属性的值，而在 ngOnInit 方法中，我们能正常获取输入属性的值。因为 ChildComponent 组件的构造函数会优先执行，当 ChildComponent 组件输入属性变化时会自动触发 ngOnChanges 钩子，然后在调用 ngOnInit 钩子方法，所以在 ngOnInit 方法内能获取到输入的属性。 constructor应用场景 依赖注入，初始化值 ngOnInit 应用场景 在组件获取输入属性之后，需执行组件初始化操作 总结: 在 Angular 4 中 constructor 一般用于依赖注入或执行简单的数据初始化操作，ngOnInit 钩子主要用于执行组件的其它初始化操作或获取组件输入的属性值","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular2 VS angular4 对比: 特性、性能","slug":"angular2-VS-angular4-对比-特性、性能","date":"2018-06-18T08:58:48.000Z","updated":"2018-06-18T09:05:12.984Z","comments":true,"path":"angular2-VS-angular4-对比-特性、性能.html","link":"","permalink":"https://zristart.github.io/angular2-VS-angular4-对比-特性、性能.html","excerpt":"","text":"Angular2是在2015年底发布的。接下来一起了解Angular2这个版本发布的原因以及如何将其添加到Web开发中。 这个Angular版本更加注重于开发移动应用程序，开发人员可以使用它创建跨平台的应用程序，在解决了移动应用程序（功能，加载时间等）的挑战后，Angular2可以更容易的处理桌面组件。 许多模块被淘汰出了Angular核心，这也促使Angular2具备更好的性能。Angular走向了不断增长的模块生态系统，这意味着开发者可以自由的选择所需的组件。 Angular 2.0基于ES6标准和“evergreen”现代浏览器（可自动更新到最新版本的浏览器）。在这些浏览器上构建应用，意味着可以更容易的使用Angular进行开发和优化，从而允许开发人员更专注于公司业务实现的代码。 Angular2 的特性和性能AtScript是ES6的超集，用于帮助Angular2的开发。它由Traceur编译器（结合ES6）进行处理，然后生成ES5代码，并使用TypeScript语法创建运行时类型断言。但是，AtScript不是强制性的，开发人员仍然可以选择只使用纯JavaScript / ES5代码来构建Angular应用程序。 提升依赖注入（DI）：依赖注入（一种程序设计模式，可以通过依赖关系实现调用，而不需要生成）是一种Angular显著区别于其竞争对手的特性。依赖注入在模块化开发和元素隔离方面非常有帮助，但它的实现一直受到Angular 1.x的困扰。Angular2解决了这个问题，另外还添加了一些缺少的功能，如子注入以及生命周期/范围控制。 注解：AtScript提供了连接元数据和功能的工具。通过在DI库中提供基本信息（可以调用函数或创建类的实例来检查相关元数据），从而简化了对象实例的构建。通过提供注入注释，使得参数信息重写也变得简单。 子注入：子注入继承了其父级注入所有的专业服务，以及在子层次重写的能力。根据需要，在一定范围内，一些类型的对象可以被调用和机械的重写。 实例范围：增强的DI库是由实例范围控制器组成的，当与子注入器连同范围标识符一起使用时，会更加强大。 动态载入：这是之前的Angular版本均不具备的功能，Angular2包含了这个功能，即使在开发人员忙碌时，也能够添加新的指令或控件。 模板：在Angular2中，模板编译过程是异步的。由于代码依赖于ES6模块，因此模块加载程序将通过在部分组件上引用它们，来加载依赖关系。 指令：Angular2提供了三种指令： 组件指令：通过将逻辑封装在HTML，CSS和JavaScript中，从而使得组件可复用。装饰器指令：可用于装饰元素（例如，通过隐藏/显示元素ng-hide/ng-show或添加工具提示）。模板指令：可以将HTML转换为可复用的模板。该模板的实例化以及插入到DOM过程可以完全由指令创建者控制。例如ng-repeat和ng-if。 子路由子路由将通过提供自身的路由功能，将程序的每个部分转换为更紧密的应用程序，这有助于整个程序功能集合的封装。 Screen Activator：通过Angular 2，开发人员可以通过一系列can *回调对导航生命周期进行更好的控制。 canActivate：它允许或阻止导航到新的控件。激活：它会响应导航到新控件的成功事件。canDeactivate：它将防止或允许跳出旧控制器的导航。停用：它会响应跳出旧控制器的成功事件。 设计：所有这些逻辑都是使用管道架构创建的，这使得将自己的操作添加到管道中或删除默认操作变得非常简单。此外，它的异步字符允许开发人员在管道中，实现对用户进行身份验证或加载控件信息的服务器请求。 记录：Angular 2.0包括一个名为diary.js的日志记录服务，这是一个非常有用的属性，用于测量开发人员的编码投入时间（从而允许开发人员识别代码中的瓶颈）。 scope：$scope 从Angular2中删除了。 Angular4 Angular4 的特性和性能相比于Angular 2，Angular4的功能列表中添加了许多新功能，同时还有一些旧功能的改进。 更小更快：使用Angular4，程序将会消耗更少的空间，并比以前的版本运行地更快。工作主要用于不断进行改进。 视图引擎：Angular4的开发人员修改了视图引擎的代码，例如AOT创建的代码。这些修改促使视图部分生成的代码大小减少了大约60％。模板越是复杂，节省的就越多。 动画包：Angular4的开发人员将动画从Angular的核心部分提取出来，并将它们放在独立的包中。这意味着如果开发人员不需要使用动画，就可以不创建这些额外的代码。 这个功能还能够帮助更方便的查找docs文件和使用自动完成功能。开发人员可以通过为@angular/platform-b​​rowser/animations引入浏览器动画模块，从而实现为主要的NgModule添加动画功能。 改进 ngIf 和 ngFor：模板绑定语法目前支持一些少量有帮助的更改。现在，开发人员已经可以使用if/else设计​​语法，并分配局部变量了。 Angular Universal：此版本是Universal团队几个月的工作成果。这个Universal版本的代码的绝大多数目前位于@angular/platform-server。 TypeScript 2.1和2.2兼容性：Angular4开发组将Angular升级为更新版本的TypeScript。这将提高ngc的速度，方便开发人员将在编码过程中更好的进行类型检查。 模板的源映射：每当模板中的某些内容出现错误时，都将创建源映射，为原始模板提供有意义的说明内容。 结论：对于仍处于学习阶段的人来说，Angular会有点混乱。但对于具有Angular2知识的有经验的开发人员来说，会觉得Angular很容易使用，并且使用Angular对项目非常有帮助。 原文地址: https://dzone.com/articles/angular-2-vs-angular-4-features-performance","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular4 Directive Lifecycle","slug":"angular4-Directive-Lifecycle","date":"2018-06-18T08:11:30.000Z","updated":"2018-06-18T09:09:43.011Z","comments":true,"path":"angular4-Directive-Lifecycle.html","link":"","permalink":"https://zristart.github.io/angular4-Directive-Lifecycle.html","excerpt":"","text":"angular 指令(Directive)组件(Component)的关系: - Component 继承(extends) Directive - (组价) Component 是 (指令)Directive 的组成部分 1234567891011121314151617181920212223export interface Directive &#123; selector?: string; // 用于定义组件在HTML代码中匹配的标签 inputs?: string[]; // 指令的输入属性 outputs?: string[]; // 指令的输出属性 host?: &#123;[key: string]: string&#125;; // 绑定宿主的属性、事件等 providers?: Provider[]; // 设置指令及其子指令可以用的服务 exportAs?: string; // 导出指令，使得可以在模板中调用 queries?: &#123;[key: string]: any&#125;; // 设置指令的查询条件&#125;export interface Component extends Directive &#123; changeDetection?: ChangeDetectionStrategy; // 指定组件使用的变化检测策略 viewProviders?: Provider[]; // 设置组件及其子组件(不含ContentChildren)可以用的服务 moduleId?: string; // 包含该组件模块的 id，它被用于解析 模版和样式的相对路径 templateUrl?: string; // 为组件指定一个外部模板的URL地址 template?: string; // 为组件指定一个内联的模板 styleUrls?: string[]; // 为组件指定一系列用于该组件的样式表文件 styles?: string[]; // 为组件指定内联样式 animations?: any[]; // 设置组件相关动画 encapsulation?: ViewEncapsulation; // 设置组件视图包装选项 interpolation?: [string, string]; // 设置默认的插值运算符，默认是&quot;&#123;&#123;&quot;和&quot;&#125;&#125;&quot; entryComponents?: Array&lt;Type&lt;any&gt;|any[]&gt;; // 设置需要被提前编译的组件&#125; 指令与组件共有的钩子 ngOnChanges // 当数据绑定输入属性的值发生变化时调用 (1) ngOnInit // 在第一次 ngChanges 后调用 (2) ngDoCheck // 自定义的方法，用于检测和处理值的改变 (3) ngOnDestory // 指令销毁前调用 (8) 组件特有的钩子 ngAfterContentInit // 在组件内容初始化之后调用 (4) ngAfterContentChecked // 组价每次检查内容时调用 (5) ngAfterViewInit // 组件相应的视图初始化之后调用 (6) ngAfterViewChecked // 组件每次检查视图时调用 (7) constructor 构造函数 组件的生命周期函数会在所有生命周期钩子调用之前调用， 一般初始化数据，或者依赖注入用. ngOnChanges 当数据绑定输入属性的值发生改变时，Angular会主动调用ngOnChanges方法, 他会获得一个SimpleChanges对象， 包含绑定的旧值新值，用于检测组件的输入属性的变化. ngOnInit(只会被调用一次) 在ngOnChanges执行之后，会调用ngOnInit， 执行组件的其他操作或获取组件输入属性的值。 1234567891011121314151617181920212223242526import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;Welcome to Angular World&lt;/h1&gt; &lt;p&gt;Hello &#123;&#123;name&#125;&#125;&lt;/p&gt; `,&#125;)export class AppComponent implements OnInit &#123; name: string = &apos;&apos;; constructor() &#123; console.log(&apos;Constructor initialization&apos;); this.name = &apos;Semlinker&apos;; &#125; ngOnInit() &#123; console.log(&apos;ngOnInit hook has been called&apos;); &#125;&#125;// 输出的结果为: Constructor initialization ngOnInit hook has been called ngOnDestory 在指令被销毁前调用，用于清理操作,比如: 清理定时器,移除事件监听、退订Observable等 ngDoCheck 在组件的输入属性发生变化时触发，自定义我们的检测逻辑。它也可以用来加速我们变化检测的速度 ngAfterContenInit 在组件使用 ng-content 指令的情况下，Angular 会在将外部内容放到视图后用 它主要用于获取通过 @ContentChild 或 @ContentChildren 属性装饰器查询的内容视图元素 ngAfterContentChecked 在组件使用 ng-content 指令的情况下，Angular 会在检测到外部内容的绑定或者每次变化的时候调用 ngAfterViewInit 在组件相应的视图初始化之后调用，它主要用于获取通过 @ViewChild 或 @ViewChildren 属性装饰器查询的视图元素 ngAfterViewChecked 组件每次检查视图时调用","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"angular4 指令","slug":"angular4-指令","date":"2018-06-18T07:24:18.000Z","updated":"2018-06-18T08:15:34.083Z","comments":true,"path":"angular4-指令.html","link":"","permalink":"https://zristart.github.io/angular4-指令.html","excerpt":"","text":"angular 4 中指令分为以下三种 组件(Component directive): 用于构建UI组件，集成Directive类 例如: ngStyle 、ngClass 属性指令(Attrbute directive): 用于改变组件的外观或者行为 例如: ngIf、 ngFor、ngSwitch 结构指令(Structural directive): 用于动态添加删除DOM元素来改变DOM布局 自定义属性指令实现:123456789101112131415161718192021222324252627282930import &#123;Directive, Input, ElementRef, Renderer, HostListener&#125; from &apos;@angular/core&apos;;@Directive(&#123; seletor: &apos;[exeBackground]&apos;&#125;)export class exeBackground &#123; private _defaultColor = &apos;red&apos;; @Input(&apos;exeBackground&apos;) backgroundColor: string; // 输入属性，用于设置元素的背景颜色 construtor(private elementRef: ElementRef, private renderer: Renderer ) &#123; this.setStyle(this._defaultColor); &#125; HostListener(&apos;click&apos;) onClick() &#123; // 监听宿主的点击事件，设置元素的背景 this.setStyle(this.backgroundColor || this._defaultColor); &#125; private setStyle(style: string) &#123; // 调用rendener对象提供的API设置元素的背景颜色 this.rendener.setElementStyle(this.element.nativeElement, &apos;backgroundColor&apos;, color ); &#125;&#125; 自定义结构型指令实现:123456789101112131415161718192021import &#123; ... &#125; from &quot;@angular/core&quot;;@directive(&#123; selector: &apos;[exeUnClass]&apos;&#125;)export class UnClassDirective &#123; @Input(&apos;exeUnClass&apos;) set condition(newCondition: boolean) &#123; if (!newCondition) &#123; this.viewContainer.createEmbeddedView(this.templateRef) &#125; else &#123; this.viewContainer.clear(); &#125; &#125; constructor(private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef ) &#123; // code... &#125;&#125;","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"https://zristart.github.io/tags/angular/"}]},{"title":"Hexo next主题安装algolia","slug":"Hexo-next主题安装algolia","date":"2018-06-15T09:56:29.000Z","updated":"2018-06-15T10:16:29.780Z","comments":true,"path":"Hexo-next主题安装algolia.html","link":"","permalink":"https://zristart.github.io/Hexo-next主题安装algolia.html","excerpt":"","text":"一直在使用hexo写自己的博客,最近博客刚刚搬家重新搞了下博客: 1、为hexo添加站内搜索 我用的是algolia,在next主题5.x以上的版本集成了algolia站内搜索功能，我们只需要简单的配置下就可以使用:安装:1npm install hexo-algolia --save 配置:123456789algolia: applicationID: &apos;your applicationID&apos; apiKey: &apos;your apiKey&apos; adminApiKey: &apos;your adminApiKey&apos; indexName: &apos;your indexName&apos; chunkSize: 500``` 设置好之后，执行下面的语句: hexo cleanhexo algolia12现在修改NexT主题集成Algolia,打开them下面的_config.xml配置文件,增加如下配置: algolia: true`","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://zristart.github.io/tags/hexo/"},{"name":"algolia","slug":"algolia","permalink":"https://zristart.github.io/tags/algolia/"}]},{"title":"记一次temcat安装","slug":"记一次temcat安装","date":"2018-06-14T15:54:07.000Z","updated":"2018-06-14T16:04:04.438Z","comments":true,"path":"记一次temcat安装.html","link":"","permalink":"https://zristart.github.io/记一次temcat安装.html","excerpt":"","text":"今天开始学习java,看了很多也想动手去写写代码。 于是乎看到网上的教程用javaee和Temcat写一个后台接口，也方便日后去写前端的时候去写点数据方便测试; 说的再多不如开始动手写起来,简单的看了下java的语法,可以看懂。现在我要在本机电脑上安装Temcat服务器,它是免费开源的。数据库mysql安装上篇文章 不会的小伙伴可以看哈。 现在我们开始安装Temcat去找对应版本下载，我这里所使用的是7.x的，下载完成后到你的本地目录找到对应的文件，解压缩，找到../bin文件夹下的 startup.bat 双击打开即可使用。 未完待续。","categories":[],"tags":[{"name":"temcat","slug":"temcat","permalink":"https://zristart.github.io/tags/temcat/"}]},{"title":"记一次mysql安装过程中所踩过的坑","slug":"记一次mysql安装过程中所踩过的坑","date":"2018-06-14T11:41:38.000Z","updated":"2018-06-14T12:01:48.498Z","comments":true,"path":"记一次mysql安装过程中所踩过的坑.html","link":"","permalink":"https://zristart.github.io/记一次mysql安装过程中所踩过的坑.html","excerpt":"","text":"写前端这么久了，想着写写后台，说干就干 首先我的后台是用java语言写 javaweb. 开始装我们的mysql数据库吧，首先去mysql去下载对应的版本开始装机，我所使用的是windows机器, download –&gt; community –&gt; mysql community server 开始下载.. 下载好后，解压下载的压缩包放到你的本地磁盘d中D:\\mysql ok, 至此我们的mysql装好了， 现在配置环境在myslq解压的当前目录下新建my.ini文件,开始写我们的配置文件 12345678910111213141516171819202122232425[mysql]# 设置mysql 默认字符集default-chartacter-set=uft8[mysqld]# 设置端口port = 3306# mysql安装目录basedir=D:\\mysql# 设置mysql数据库存放位置datadir = D:\\mysql\\data# 允许最大连接数max_connections=20# 服务器端使用的字符集默认为8比特编码的latin1字符集characset-set-server=utf8# 创建新表时将使用默认存储引擎default-storage-engine=INNODB# 快速设置mysql的密码#skip-grant-tables OK,至此mysql的初始化工作已经完成, 现在要将mysql添加到环境变量中去, 具体做法 [D:\\mysql] 添加到path中去, 记得用分号隔开; 安装服务: mysqld install ; 记得是在你的安装mysql目录中bin文件夹内, cmd使用管理员权限; 环境变量配置完成, 现在我们开启mysql服务 net start mysql 这时候往往会报这种错误 [mysql服务无法启动 服务没有报告任何错误 ] 那该怎么处理呢？ OK, 回到之前我们在写配置文件时 datadir=D:\\mysql\\data 这个, 这里不要手动创建这个data文件夹,使用命令创建1mysqld --initialize-insecure 这时候会发现,data目录已经被创建完毕,里面的配置文件也齐全，OK 现在我门开启 mysql 1net start mysql 这时服务已经启动成功！","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://zristart.github.io/tags/mysql/"}]},{"title":"ionic3 生命周期钩子","slug":"ionic3-生命周期钩子","date":"2018-06-07T03:50:10.000Z","updated":"2018-06-07T03:56:46.244Z","comments":true,"path":"ionic3-生命周期钩子.html","link":"","permalink":"https://zristart.github.io/ionic3-生命周期钩子.html","excerpt":"","text":"ionViewDidLoad页面加载完成触发，这里的“加载完成”指的是页面所需的资源已经加载完成，但还没进入这个页面的状态（用户看到的还是上一个页面）。 需要注意的是它是一个很傲娇的钩子，全程只会调用一次，即第一次进入页面时被调用，此后你无论怎样进进出出它都冷冷清清凄凄惨惨戚戚不再理你了。除非你把它的后台杀了，重新进入这个软件（在网页调试的时候按刷新也是可以的）。 因此这个钩子适合你做一些一次性的处理，比如从服务器拉取用户数据存到缓存中。 ionViewWillEnter字面意义理解就是“我要进来了”的那一刻，这个时候页面刚刚开始切换。你可以在这时对页面的数据进行预处理，这个钩子是每次都会调用的 ionViewDidEnter当这个钩子被触发的时候，用户已经进入到新页面了（页面处于激活状态），同样也是每次都会调用。 说到这我不得不插一句，ionic对钩子的命名对广大中国学生真是友好啊，一个will一个did就把事情解决了。不像外边某些妖艳（误）的框架，一堆ready, update, complied, destory什么的，记一次忘一次。（当然这是一个玩笑，组件的命名跟框架的运行机制是息息相关的） ionViewWillLeave页面准备 (is about to) 离开时触发，这时用户刚刚触发了返回按钮或者相关的事件。 ionViewDidLeave页面已经 (has finished) 离开时触发，页面处于非激活状态了。 ionViewWillUnload页面中的资源即将被销毁时触发，此刻你是否会猜测这个钩子与ionViewDidLoad一样，只会被触发一次呢？ 注意:构造函数在ionViewDidLoad之前被触发ionViewDidLoad只在第一次进入页面时触发ionViewWillUnload会在每次离开页面后触发 守卫钩子ionViewCanEnterionViewCanLeave1234567891011121314151617//和蔼可亲的班主任 ionViewCanEnter() :boolean &#123; if(new Date().getHours()&gt;=8)&#123; console.log('怎么的呢，你看看现在几点了，你那么舒服咋不在家里接着睡吶，给我门外站着去！'); return false; &#125; return true; &#125;//杏花楼姿态万千的老鸨 ionViewCanLeave() :boolean &#123; if(new Date().getHours()&gt;=22)&#123; console.log('哎呀公子，你看都这么晚了，最近外面风声那么紧，不如就在我们这儿留宿吧，你看姑娘们都舍不得你回去呢'); return false; &#125; return true; &#125; 总结ionViewDidLoad 第一次调用 返回voidionViewWillEnter 每次调用 返回voidionViewDidEnter 每次调用 返回voidionViewWillLeave 每次调用 返回voidionViewDidLeave 每次调用 返回voidionViewWillUnload 每次调用 返回voidionViewCanEnter 每次调用 返回booleanionViewCanLeave 每次调用 返回boolean","categories":[],"tags":[{"name":"ionic3","slug":"ionic3","permalink":"https://zristart.github.io/tags/ionic3/"}]},{"title":"angular学习之路","slug":"angular学习之路","date":"2018-06-05T08:20:50.000Z","updated":"2018-06-05T08:21:58.565Z","comments":true,"path":"angular学习之路.html","link":"","permalink":"https://zristart.github.io/angular学习之路.html","excerpt":"","text":"中文官网 https://www.angular.cn","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"https://zristart.github.io/tags/Angular/"}]},{"title":"ionic使用中所遇到的坑","slug":"ionic使用中所遇到的坑","date":"2018-06-01T07:10:00.000Z","updated":"2018-06-05T06:17:02.567Z","comments":true,"path":"ionic使用中所遇到的坑.html","link":"","permalink":"https://zristart.github.io/ionic使用中所遇到的坑.html","excerpt":"","text":"总结一下我在使用ionic3中所遇到的问题在这里总结下: 首先最新版ionic在我们构建好项目、启动成功后，修改过文件或者是刷新浏览器的情况下，我们的ionic项目运行在终端的servce会中断这是因为其中一个模块的问题(ws),进入到node_module中删除他，之后在命令行执行 npm install ws@3.3.2 –save, 安装完毕后重新启动项目，搞定。 在构建服务时，有时候会忘记引入http服务，我们在组建中药引入http模块，同样在app.module.ts中也要引入httpModule模块， 否则会报错。 我们在写代码时,常常会遇到跨域问题,解决ionic3跨域问题的方法: 我们找到项目根目录下的ionic.config.json配置文件,在里面添加如下配置 123456\"proxies\": [ &#123; \"path\": \"/list\", \"proxyUrl\": \"https://m.toutiao.com/list/\" &#125; ]","categories":[],"tags":[{"name":"ionic","slug":"ionic","permalink":"https://zristart.github.io/tags/ionic/"}]},{"title":"使用Digitalocean搭建SS并使用BBR加速","slug":"使用Digitalocean搭建SS并使用BBR加速","date":"2018-05-19T01:09:50.000Z","updated":"2018-05-19T01:14:16.175Z","comments":true,"path":"使用Digitalocean搭建SS并使用BBR加速.html","link":"","permalink":"https://zristart.github.io/使用Digitalocean搭建SS并使用BBR加速.html","excerpt":"","text":"服务器: ubuntu 14.01 64本地电脑: ubuntu 16.04 64 首先我自己本想着买vpn, 但是作为技术出身的我来讲，靠人不如靠己，自己动手风衣足食。 首先我我选择的是Digtailocean进去注册，我选 择的是每个月5$的, 系统选用的是ubuntu 14.01 64位， 至此我们的服务器搞定。 首先我们在本地 【 Crt+Shift + T 】打开本地终端, 链接服务器 [ssh -t root@公网ip地址 -p 22] 首先我们修改服务器密码, 主要 默认密码会发送到你填写的邮箱，刚开始要输入两次密码， 有点变态 OK修改号密码之后就登录成功了，接下来就是安装ss环境了。 123apt-get updateapt-get install python-gevent python-pip python-m2crypto python-wheel python-setuptoolspip install shadowsocks 安装好之后就是修改配置文件了 1234567891011&#123; &apos;server&apos;: &apos;your ip&apos;, &apos;server_port&apos;: 8083, &apos;local_address&apos;: &apos;127.0.0.1&apos;, &apos;local_port&apos;: 1080, &apos;password&apos;: &apos;密码&apos;, &apos;timeout&apos;: 300, &apos;method&apos;: &apos;aes-256-cfb&apos;, &apos;fast-open&apos;: false&#125; 至此位置,配置文件已搞定, 接下来该开启服务了 1ssserver -c /etc/shadowsols.json -d start 搞定！ 接下来，开始安装BBR谷歌的黑科技，服务端加速。这里由详细教程。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"https://zristart.github.io/tags/工具/"}]},{"title":"学习笔记之(四)webpack热更新","slug":"学习笔记之-四-webpack热更新","date":"2018-05-19T01:08:47.000Z","updated":"2018-05-19T01:09:12.367Z","comments":true,"path":"学习笔记之-四-webpack热更新.html","link":"","permalink":"https://zristart.github.io/学习笔记之-四-webpack热更新.html","excerpt":"","text":"1、Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信) 2、页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端 3、客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash 4、修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端 5、客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档 6、hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zristart.github.io/tags/webpack/"}]},{"title":"学习笔记(三)webpack实际开发中的应用","slug":"学习笔记-三-webpack实际开发中的应用","date":"2018-05-19T01:05:24.000Z","updated":"2018-05-19T01:08:23.612Z","comments":true,"path":"学习笔记-三-webpack实际开发中的应用.html","link":"","permalink":"https://zristart.github.io/学习笔记-三-webpack实际开发中的应用.html","excerpt":"","text":"现在我们来到我们的开发目录, 那么实际开发中吧我们的小技巧告诉大家 一、source map在实际项目开发中，我们会常常遇到把几个文件(a.js, b.js, c.js)打包为一个bundle.js文件， 时常会遇到其中一个文件打包出错了,那么我们很难定位到错误位置，为了更加容易地指认错误和警告， Javascript提供的source map功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 二、自动化构建工具webpack watch modelwebpack dev serverwebpack dev middleware 实时监控代码，一旦代码被修改将自动重新编译 123\"script\": &#123; \"watch\": \"webpack --watch\"&#125; 使用webpack-dev-server这个模块提供了一个简单的web服务,并且能实时重新加载1npm install --save-dev webpack-dev-servre 使用webpack-dev-middleware 他可以把webpack处理后的文件传递给一个服务器，也可以作为一个独立的模块使用.","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zristart.github.io/tags/webpack/"}]},{"title":"webpack配置文件","slug":"webpack配置文件","date":"2018-05-19T01:03:47.000Z","updated":"2018-05-19T01:05:12.334Z","comments":true,"path":"webpack配置文件.html","link":"","permalink":"https://zristart.github.io/webpack配置文件.html","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const path = require('path');module.exports = &#123; // 入口文件entry: './src/index.js',// 输出文件output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist')&#125;,module: &#123; rules: [ &#123; // css 样式加载 test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; // 图片加载 test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, &#123; // 加载字体 test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, &#123; // 加载数据 test: /\\.(csv|tsv)$/, use: [ 'css-loader' ] &#125;, &#123; // xml文件 test: /\\.xml$/, use: [ 'xml-loader' ] &#125; ] &#125;&#125;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zristart.github.io/tags/webpack/"}]},{"title":"学习笔记之webpack配置篇","slug":"学习笔记之webpack配置篇","date":"2018-05-18T15:14:05.000Z","updated":"2018-05-18T15:16:59.880Z","comments":true,"path":"学习笔记之webpack配置篇.html","link":"","permalink":"https://zristart.github.io/学习笔记之webpack配置篇.html","excerpt":"","text":"webpack是现在前端一款很好的文件配置加载工具， 我们自已很轻松使用他构建我们的项目。 首先我们要在我们的工作环境安装webpack环境依赖 1npm install webpack --sava 现在来到我们的项目下,新建文件webpack的配置文件webpack.config.js 123456789101112const path = require('path');module.expres = &#123; // 要编译的入口文件 entry: '[name].js', output: &#123; // 编译输出文件 filename: 'name.js', // dist 是要输出的文件路径 path: path.resolve(__dirname, 'dist') &#125;&#125; 现在我们来到package.json文件里面, 修改以下对应内容 1234// 编译命令script: &#123; build: 'webpack'&#125; 现在我们回来命令行输入 1npm run build OK, 至此一个简单的webpack配置环境就算搭建完成了。","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://zristart.github.io/tags/webpack/"}]},{"title":"项目迁移","slug":"项目迁移","date":"2018-05-18T14:20:46.000Z","updated":"2018-05-18T14:21:36.294Z","comments":true,"path":"项目迁移.html","link":"","permalink":"https://zristart.github.io/项目迁移.html","excerpt":"","text":"之前的博客现在已经迁移到这块","categories":[],"tags":[]}]}