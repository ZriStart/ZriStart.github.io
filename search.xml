<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>“延禧配色”是怎么调出来的？调色总监亲自教你!</title>
      <link href="/%E2%80%9C%E5%BB%B6%E7%A6%A7%E9%85%8D%E8%89%B2%E2%80%9D%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F%E8%B0%83%E8%89%B2%E6%80%BB%E7%9B%91%E4%BA%B2%E8%87%AA%E6%95%99%E4%BD%A0.html"/>
      <url>/%E2%80%9C%E5%BB%B6%E7%A6%A7%E9%85%8D%E8%89%B2%E2%80%9D%E6%98%AF%E6%80%8E%E4%B9%88%E8%B0%83%E5%87%BA%E6%9D%A5%E7%9A%84%EF%BC%9F%E8%B0%83%E8%89%B2%E6%80%BB%E7%9B%91%E4%BA%B2%E8%87%AA%E6%95%99%E4%BD%A0.html</url>
      <content type="html"><![CDATA[<p>随着暑假即将结束<br>《延禧攻略》也落下了帷幕<br>但是电视剧中古朴典雅的色调<br>却一直被大家所津津乐道</p><p>今天大大君分享的这篇文章<br>是《延禧攻略》的调色总监孙婷<br>亲自写就的“调色攻略”</p><p><img src="/images/ui/1_gw.gif" alt=""></p><p>关于延禧攻略的色调灵感</p><p>整体设计灵感来自于中国国画的绢本设色的画作（绢本：绘在绢、绫、丝织物上的字画。设色：在画作上晕染颜色。）绢本设色的绘画作品，由于是在麦色织物上作画上色，绢本的麦色底色的这一独特元素，造就了中国国画深沉厚重的古朴的质感。</p><p>《延禧攻略》时代背景发生在清朝乾隆年间。对于清朝画家，孙婷深爱冷枚的《春闺倦读图》和宫廷画师郎世宁的《午端图》。</p><p>（清）冷枚《春闺倦读图》<br><img src="/images/ui/2_gw.gif" alt=""><br><img src="/images/ui/3_gw.gif" alt=""><br><img src="/images/ui/4_gw.gif" alt=""></p><p>（清）郎世宁《午端图》<br><img src="/images/ui/5_gw.gif" alt=""></p><p>冷枚的《春闺倦读图》中的满族仕女，温婉恬静，妩媚动人。</p><p>郎世宁自不用说，本人就是宫廷画师，他把西方的绘画技法运用到工笔画作画上，形成细致逼真的效果，一直深受皇室喜爱。</p><p>（清）郎世宁《锦春图》<br><img src="/images/ui/6_gw.gif" alt=""></p><p>（清）冷枚《梧桐双兔图》<br><img src="/images/ui/7_gw.gif" alt=""></p><p>(清) 郎世宁《雍正十二月圆明园行乐图》<br><img src="/images/ui/8_gw.gif" alt=""></p><p>根据绢本画作麦色底所呈现的独特质感，在《延禧攻略》色调创意中加入麦色底色，再根据不同时间，场景，故事，人物设定等对于麦色底浓度色彩偏向进行调整，在保证画面固有色的基础上逐层推进叠加其他色彩加以配比形成如今看到的古画作质感。</p><p>这两幅画一人，一物，伴随着绢本厚重的古典气息便成了《延禧攻略》色调最初的灵感………</p><p>关于《延禧攻略》的配色与色彩整合调整</p><p>《延禧攻略》本剧前期设定服化道，美术，摄影构图都十分精致，大到场景，人物造型服装，小到配饰道具无不精美考究，带给人一种古色古香的视觉体验。</p><p>所以根据本剧的定位后期调色在配色上全部采用中国传统色系。中国传统色系具有一套完整的色彩体系与寓意，几千年来融入古人生活中的衣食住行方方面面，不同的色彩但都有着不约而同的美好名字，且每个颜色都寓意深远，或热烈或悠远，或庄严或张扬，或悲壮或堂皇……色与物相互作比，常常又生出另一道深远美好的光景……</p><p>比如绛红色，白居易写山茶花：</p><p>似有浓妆出绛纱，行充一道映彩霞。<br><img src="/images/ui/9_gw.gif" alt=""></p><p>杨万里写水红色的荷：<br>接天莲叶无穷碧 ，映日荷花别样红。<br><img src="/images/ui/10_gw.gif" alt=""></p><p>《诗经 ·淇奥》用青青绿竹比喻君子：</p><p>瞻彼淇奥，绿竹青青。<br>有匪君子，充耳琇莹，会弁如星。<br><img src="/images/ui/11_gw.gif" alt=""></p><p>中国色系用自己独特的魅力<br>装点着古人的生活和精神世界<br><img src="/images/ui/12_gw.gif" alt=""></p><p>对于古装剧色调制作，一大难点在于各项配色与人物环境是否协调，是否能很好的服务于画面的整体效果。</p><p>本次《延禧攻略》色调所采用的中国传统色系最大特点就是以天然植物，动物，矿物作为色彩原料，这样的来自自然界的颜色，色彩范围广又极富生命力，少了工业化学染剂色的呆板锋利，多了一份温润柔和。能更好的将观众带入故事设定发生的时代。<br><img src="/images/ui/13_gw.gif" alt=""><br><img src="/images/ui/14_gw.gif" alt=""></p><p>在古装剧具体画面中制作调色则需要将所有呈现工业染剂色彩进修正，改善。使画面中所有色彩在固有色不变的基础上更融入大色调，颜色即富有个性又不至于某种色彩十分出挑抢眼，做到在还原突出质感的基础上又不至杂乱无章。</p><p>整体场景画面配色中，调色要服务于剧情设定需要，去除多余杂色，辅助摄影、灯光，根据环境气氛，加强光影效果。感官上使画面更具有冲击力，更好辅助演员表演情绪所展现出的气氛。<br><img src="/images/ui/15_gw.gif" alt=""><br><img src="/images/ui/16_gw.gif" alt=""><br><img src="/images/ui/17_gw.gif" alt=""><br><img src="/images/ui/18_gw.gif" alt=""></p><p>同时调色也要根据不同的人物身份性格，对不同人物的住所做了一定的设计。</p><p>例如皇帝的养心殿，加入了一些明黄色，彰显皇帝九五至尊的地位。<br><img src="/images/ui/19_gw.gif" alt=""></p><p>白月光皇后娘娘的居所长春宫则加入了一些更温暖的杏黄色，表现出皇后娘娘的温柔贤淑.<br><img src="/images/ui/20_gw.gif" alt=""></p><p>娴妃前期一心心系皇帝，与世无争，她的承乾宫前期更为清雅，后期她被逼黑化，居所色调中加入一些暖色调，更为沉重，既表现她觊觎后位的野心，也展现她取而代之的决心。</p><p>娴妃黑化前期<br><img src="/images/ui/21_gw.gif" alt=""></p><p>前期令妃待了很久的绣坊，则加入一些嫣红色表现刚入宫的一群小姑娘充满青春的气息。<br><img src="/images/ui/22_gw.gif" alt=""></p><p>画面中出现面积最大的配色便是各位娘娘精致的服装，特别是刺绣运用全三色，显五彩，素五彩，淡单色，雅单色，补色，借色，京绣中艳而不俗的配色等等，都十分精美异常。</p><p>绣制在罗，丝，绸，缎等不同质地的衣料上所呈现的质感光泽也不尽相同。调色则需要整合所有刺绣服装色彩让多种不同色彩都很好的融入画面色调中，在不伤害固有色的前提下再次更贴近所使用的中国传统色系，达到深沉古典但不失生命力的感观效果。</p><p>例如红色调整为胭脂，绯红等色<br><img src="/images/ui/23_gw.gif" alt=""><br><img src="/images/ui/24_gw.gif" alt=""></p><p>蓝色多调整为靛蓝，藏青，绀青等色<br><img src="/images/ui/25_gw.gif" alt=""><br><img src="/images/ui/26_gw.gif" alt=""></p><p>绿色多调整为松花绿，绿沈，<br>青碧，豆绿，竹青，黛绿等色<br><img src="/images/ui/27_gw.gif" alt=""><br><img src="/images/ui/28_gw.gif" alt=""><br><img src="/images/ui/29_gw.gif" alt=""><br><img src="/images/ui/30_gw.gif" alt=""><br><img src="/images/ui/31_gw.gif" alt=""></p><p>黄色调整为杏黄，缃色，<br>赤金色，黄栌，棕黄等色</p><p><img src="/images/ui/32_gw.gif" alt=""><br><img src="/images/ui/33_gw.gif" alt=""><br><img src="/images/ui/34_gw.gif" alt=""></p><p>不仅仅是对于服装，包括剧中人物妆容色彩，首饰部分的点翠的色泽，绒花，玉器，瓷器，金、银、铜器的光泽质感，瓦砾梁柱，宫墙，漆器等调色都要在保证原有固有色的基础上根据整体色调进行整合调整，使每种色彩都更加发挥出有中国传统色彩的深沉柔和感，更好的服务于画面与故事剧情。<br><img src="/images/ui/35_gw.gif" alt=""></p><p>调色在制作剧集过程中，不光要对正戏进行色调创作和制作，调色也要对其他与剧集有关的物料画面进行调整。大家大爱的片头也进行了调整，修正为更具有古画气氛的色调，使其与正戏色调达到呼应统一。</p><p><img src="/images/ui/36_gw.gif" alt=""><br><img src="/images/ui/37_gw.gif" alt=""><br><img src="/images/ui/38_gw.gif" alt=""><br><img src="/images/ui/39_gw.gif" alt=""><br><img src="/images/ui/40_gw.gif" alt=""></p><p>调色作为影视剧不可或缺的二次艺术创作部分，需要把这种二次创作发挥到极致。画面色彩是一部剧最直观的感受，精准细致的色调制作，可以更好的在观感上迅速确立一部剧的定位与气质，为剧锦上添花。</p><p>欢迎转载，如有侵权请联系作者删除!</p>]]></content>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>深入React.js技术栈</title>
      <link href="/%E6%B7%B1%E5%85%A5React-js%E6%8A%80%E6%9C%AF%E6%A0%88.html"/>
      <url>/%E6%B7%B1%E5%85%A5React-js%E6%8A%80%E6%9C%AF%E6%A0%88.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>node事件循环机制</title>
      <link href="/node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.html"/>
      <url>/node%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vuex浅析</title>
      <link href="/Vuex%E6%B5%85%E6%9E%90.html"/>
      <url>/Vuex%E6%B5%85%E6%9E%90.html</url>
      <content type="html"><![CDATA[<p>说到状态管理,我们知道React中的Redux,那么Vue中又有那些优秀的状态管理库呢?当然是Vuex了.</p>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue生命周期指南</title>
      <link href="/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8C%87%E5%8D%97.html"/>
      <url>/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8C%87%E5%8D%97.html</url>
      <content type="html"><![CDATA[<p>最近开始学Vue,怎么学呢？从开始阅读官方文档开始吧，不得不说Vue官方文档写的真心不错,现在就让我们开始走进今天的Vue生命周期函数吧。</p><p>这是我个人Vue生命周期函数的总结，由于本人技术尚浅，哪里错误还请多多指出。</p><p>breforeCreate<br>created<br>beforeMount</p><p>// 进行初始化事件数据初始化，我么可以看到created已经和data数据绑定上了;</p><p>–&gt; 首先会判断对象是否有el选项,如果有继续向下编译，如果没有则会停止编译,Vue的生命周期也就到此终结了。</p><p>–&gt; 如果我们注释上面的el: ‘app’这段代码的话,Vue的生命周期也就到此结束了,说明这块是Vue初始化DOM的入口点；<br>也就是DOM的挂在点</p><p>–&gt; 如果我们继续调用vm.$mount(el),Vue生命周期将会继续向下执行.</p><p>现在有一个问题，我们在生命周期函数中渲染template模板,会不会影响代码的加载时间呢？<br>请看该代码片段:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el: 挂载点</span></span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    template: <span class="string">'&lt;h1&gt;&#123;&#123;message + " 这是模板代码片段 " &#125;&#125;&lt;/h1&gt;'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            message: <span class="string">'我是vue生命周期'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created: &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">' create init '</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>想想上面这段代码会怎么执行呢？<br>是这样的,vue生命周期函数中,首先会寻找挂载点也就是el元素，挂载到DOM，整个Vue生命周期开始</p><p>beforeMount和mounted分别有做了那些动作呢?<br>组件元素渲染,这时候数据已经挂载到DOM上了。</p><p>breforeUpdate 和 update<br>更新data里面的数据,渲染DOM</p><p>beeforeDestroy和Destory<br>这是Vue生命周期的最后阶段,一般我们会再这里去销毁组件,值得注意的是在brefore中我们还是可以正常组件实例的;</p>]]></content>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React中事件this的绑定方式</title>
      <link href="/React%E4%B8%AD%E4%BA%8B%E4%BB%B6this%E7%9A%84%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F.html"/>
      <url>/React%E4%B8%AD%E4%BA%8B%E4%BB%B6this%E7%9A%84%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F.html</url>
      <content type="html"><![CDATA[<p>在React中创建事件，绑定this时长发生，那this是如何进行绑定的呢？</p><p>1、一般情况下我们会把this绑定在构造函数中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">controuctor() &#123;</span><br><span class="line">    super();</span><br><span class="line"></span><br><span class="line">    let handleDefault = this.handleDefault.bind(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot; onClick=&#123;this.handleDefault&#125;&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样做的好处在于，我们可以清晰的看到当前组件中的事件到底有哪些，对于性能优化也存在一定的好处</p><p>2、另一种情况我们会在事件上 绑定this,例如下面的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;a href=&quot;#&quot; onClick=&#123;&#123;this.handleClick().bind(this)&#125;&#125;&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>3、再者就是利用箭头函数进行绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">handleCilick = () =&gt; &#123;</span><br><span class="line">    // coding ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">render() &#123;</span><br><span class="line">    renturn(</span><br><span class="line">        &lt;a href=&quot;#&quot; onClick=&#123;(e) =&gt; this.handleClink(e)&#125;&gt;&lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事件传参<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">handleClick (e, id) =&gt; &#123;</span><br><span class="line">    // coding ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;a href=&quot;#&quot; onClick=&#123;(e) =&gt; this.handleClick(id, e)&#125;&gt;Cliclk Me&lt;/a&gt;</span><br><span class="line">        &lt;a href=&quot;#&quot; onClick=&#123;this.handleClick.bind(this, id)&#125;&gt;Cliclk Me&lt;/a&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这两者是等价的;<br>拿官方上面的一句话说明:<br>值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Popper extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state = &#123;name:&apos;Hello world!&apos;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preventPop(name, e)&#123;    //事件对象e要放在最后</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;hello&lt;/p&gt;</span><br><span class="line">                &#123;/* Pass params via bind() method. */&#125;</span><br><span class="line">                &lt;a href=&quot;https://reactjs.org&quot; onClick=&#123;this.preventPop.bind(this,this.state.name)&#125;&gt;Click&lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React组件生命周期函数</title>
      <link href="/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.html"/>
      <url>/React%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.html</url>
      <content type="html"><![CDATA[<p>按照执行顺序依次如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">constructor()&#123;&#125;</span><br><span class="line">// 组件初始化时调用，只会调用一次</span><br><span class="line">componentWillMount()&#123;&#125;</span><br><span class="line">// 组件初始化时调用，一般我们会在此调用ajax等</span><br><span class="line">componentDidMount() &#123;&#125;</span><br><span class="line">// 父组件更新时调用</span><br><span class="line">componentReceiveProps()&#123;&#125;</span><br><span class="line">// 组件更新时</span><br><span class="line">shouldComponendUpdate() &#123;&#125;</span><br><span class="line">// render 之后执行</span><br><span class="line">componentWillUpdate() &#123;&#125;</span><br><span class="line">componentDidUpdate() &#123;&#125;</span><br><span class="line">// 最后执行,用于销毁定时器，事件监听等操作</span><br><span class="line">componentWillUnmount() &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>更新方式:</p><p>1、首次渲染Initial Render<br>2、调用this.setState （并不是一次setState会触发一次render，React可能会合并操作，再一次性进行render）<br>3、父组件发生更新（一般就是props发生改变，但是就算props没有改变或者父子组件之间没有数据交换也会触发render）<br>4、调用this.forceUpdate</p>]]></content>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>清除浮动有几种方式，优缺点分别是什么</title>
      <link href="/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
      <url>/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88.html</url>
      <content type="html"><![CDATA[<p>一、 在浮动元素后加一个空的元素<div><p>, 设置clear:both; 让父元素自动获取高度；</p><pre><code>优点: 简单、代码少，浏览器支持好，不容易出现怪问题缺点: 增加了空标签，会影响浏览器的解析速度</code></pre><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span>&gt;</span><br><span class="line">　&lt;div class='fl'&gt;左浮动&lt;/div&gt;</span><br><span class="line">　&lt;div class='fr'&gt;右浮动&lt;/div&gt;</span><br><span class="line">　&lt;div class='clear'&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"><span class="comment">/*********CSS代码**********/</span></span><br><span class="line"><span class="selector-class">.fl</span>&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line"><span class="selector-class">.fr</span>&#123;<span class="attribute">float</span>:right;&#125;</span><br><span class="line"><span class="selector-class">.clear</span>&#123;<span class="attribute">clear</span>:both;&#125;</span><br></pre></td></tr></table></figure><p>二、给设置浮动的元素的父级元素添加overflow CSS属性，属性设置为hidden或者auto<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-----HTML代码----&gt;</span><br><span class="line">&lt;div class=&apos;clear&apos; &gt;</span><br><span class="line">&lt;div class=&apos;fl&apos;&gt;左浮动&lt;/div&gt;</span><br><span class="line">&lt;div class=&apos;fr&apos;&gt;右浮动&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/***********CSS代码***********/</span><br><span class="line">.fl&#123;float:left;&#125;</span><br><span class="line">.fr&#123;float:right;&#125;</span><br><span class="line">.clear&#123;</span><br><span class="line">overflow:hidden;</span><br><span class="line">zoom:1; /*兼容IE浏览器*/</span><br><span class="line">&#125;</span><br><span class="line">/***.clear&#123;overflow:auto;&#125;****/</span><br></pre></td></tr></table></figure></p><p>优点：代码少，容易上手，浏览器支持好<br>缺点：不能和position属性配合使用。同时使用position会出现以下情况：如果是使用hidden清除浮动，超出的部分会被隐藏；如果使用auto清除浮动，子元素的尺寸过大时会出现滚动条</p><p>三、使用为元素:after来清除浮动，如右边案例所示，表示在clear类的div元素后插入内容，并设置该内容的样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&apos;clear&apos; &gt;</span><br><span class="line">&lt;div class=&apos;fl&apos;&gt;左浮动&lt;/div&gt;</span><br><span class="line">&lt;div class=&apos;fr&apos;&gt;右浮动&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/***********CSS代码***********/</span><br><span class="line">.fl&#123;float:left;&#125;</span><br><span class="line">.fr&#123;float:right;&#125;</span><br><span class="line">.clear:after&#123;</span><br><span class="line">content:&apos;.&apos;;</span><br><span class="line">display:disblock;</span><br><span class="line">width:0;</span><br><span class="line">height:0;</span><br><span class="line">visibility:hidden;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br><span class="line">.clear&#123;</span><br><span class="line">zoom:1; /*兼容IE浏览器,触发hasLayout*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：浏览器支持好，不容易出现一些意想不到的问题，大型网站如新浪、网易等都有使用这个方法<br>缺点：代码较多，初学者相对其他方式不容易掌握</p><p>四、float-in-float，将父级元素和子元素都设置浮动，并在与父级元素同级的下一个相邻元素中设置clear:both;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-----HTML代码----&gt;</span><br><span class="line">&lt;div class=&apos;clear&apos; &gt;</span><br><span class="line">&lt;div class=&apos;fl&apos;&gt;左浮动&lt;/div&gt;</span><br><span class="line">&lt;div class=&apos;fr&apos;&gt;右浮动&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&apos;cnt&apos;&gt;content&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/***********CSS代码***********/</span><br><span class="line">.fl&#123;float:left;&#125;</span><br><span class="line">.fr&#123;float:right;&#125;</span><br><span class="line">.clear&#123;</span><br><span class="line">float:left;</span><br><span class="line">&#125;</span><br><span class="line">.cnt&#123;</span><br><span class="line">clear:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>缺点：可能会出现新的浮动问题</p></div></p>]]></content>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>React的setState之后都做了那些事</title>
      <link href="/React%E7%9A%84setState%E4%B9%8B%E5%90%8E%E9%83%BD%E5%81%9A%E4%BA%86%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
      <url>/React%E7%9A%84setState%E4%B9%8B%E5%90%8E%E9%83%BD%E5%81%9A%E4%BA%86%E9%82%A3%E4%BA%9B%E4%BA%8B.html</url>
      <content type="html"><![CDATA[<p>1.执行setState()之后干了什么？</p><p>setState()方法通过一个队列机制实现state更新，当执行setState()的时候，会将需要更新的state合并之后放入状态队列，<br>而不会立即更新this.state(可以和浏览器的事件队列类比)。如果我们不使用setState而是使用this.state.key来修改，将不会触发组件的re-render。<br>如果将this.state赋值给一个新的对象引用，那么其他不在对象上的state将不会被放入状态队列中，当下次调用setState()并对状态队列进行合并时，直接造成了state丢失。</p><p>2.setState()可以接受一个函数作为参数？</p><p>setState() 不仅能够接受一个对象作为参数，还能够接受一个函数作为参数。函数的参数即为 state 的前一个状态以及 props。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void setState (</span><br><span class="line">      function|object nextState,</span><br><span class="line">      [function callback]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>上述代码的第二个参数是一个回调函数，在setState() 的异步操作结束并且组件已经重新渲染的时候执行。换句话说，我们可以通过这个回调来拿到更新的state的值。</p><p>3.执行setState()后能拿到最新的state值吗？</p><p>以前在写代码时候，总是遇到明明执行过setState()，但是state的值却不是最新的，那么如何解决这个问题呢？</p><p>因为setState()函数接受两个参数，一个是一个对象，就是设置的状态，还有一个是一个回调函数，是在设置状态成功之后执行的，所以我们可以通过回掉拿到最新的state值。代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">updateData = (newData) =&gt; &#123;</span><br><span class="line">    this.setState(</span><br><span class="line">        &#123; data: newData &#125;,</span><br><span class="line">        () =&gt; &#123;</span><br><span class="line">            //这里打印的是最新的state值</span><br><span class="line">            console.log(that.state.data);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.setState()一定是异步更新吗？<a href="https://www.jianshu.com/p/a883552c67de" target="_blank" rel="noopener">原文链接</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function incrementMultiple() &#123;</span><br><span class="line">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直观上来看，当上面的 incrementMultiple 函数被调用时，组件状态的 count 值被增加了3次，每次增加1，那最后 count 被增加了3。但是，实际上的结果只给 state 增加了1。<br>事实上，setState 方法与包含在其中的执行是一个很复杂的过程，从 React 最初的版本到现在，也有无数次的修改。它的工作除了要更动 this.state 之外，还要负责触发重新渲染，这里面要经过 React 核心 diff 算法，最终才能决定是否要进行重渲染，以及如何渲染。<br>而且为了批次与效能的理由，多个 setState 呼叫有可能在执行过程中还需要被合并，所以它被设计以延时的来进行执行是相当合理的。</p><p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates<br>默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，<br>而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p><p>由 React 控制的事件处理过程 setState 不会同步更新 this.state！<br>也就是说，在 React 控制之外的情况， setState 会同步更新 this.state！</p><p>但大部份的使用情况下，我们都是使用了 React 库中的表单组件，例如 select、input、button 等等，它们都是 React 库中人造的组件与事件，是处于 React<br>库的控制之下，比如组件原色 onClick 都是经过 React 包装。在这个情况下，setState 就会以异步的方式执行。</p>]]></content>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事件冒泡和如何阻止事件冒泡</title>
      <link href="/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1.html"/>
      <url>/%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1.html</url>
      <content type="html"><![CDATA[<p>首先请看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-family:Microsoft YaHei;font-size:10px;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">document.getElementById(&quot;box1&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">alert(&quot;您好，我是最外层div。&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementById(&quot;box2&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">alert(&quot;您好，我是内层div。&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementById(&quot;span&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">alert(&quot;没错，我就是span。&quot;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>预期上述代码会单击span 的时候，会出来一个弹出框 “没错，我就是span。” 是的，确实弹出了这样的对话框<br>然而，不仅仅会产生这个对话框，当点击确定后，会依次弹出其他对话框.</p><p>解决方案:</p><p>方法一：我们来考虑一个形象一点的情况：水中的一个气泡正在从底部往上冒，而你现在在水中，不想让这个气泡往上冒，怎么办呢？<br>你首先想到的肯定就是把它扎破，扎破了自然就不会往上冒了。类似地，对某一个节点而言，如果不想它现在处理的事件继续往上冒泡的话，<br>我们可以终止冒泡。<br>加入 event.stopPropagation():<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-family:Microsoft YaHei;font-size:10px;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">document.getElementById(&quot;box1&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">alert(&quot;您好，我是最外层div。&quot;);</span><br><span class="line">event.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementById(&quot;box2&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">alert(&quot;您好，我是内层div。&quot;);</span><br><span class="line">event.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementById(&quot;span&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">alert(&quot;没错，我就是span。&quot;);</span><br><span class="line">event.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>方法二:事件包含最初触发事件的节点引用 和 当前处理事件节点的引用，那如果节点只处理自己触发的事件即可,不是自己产生的事件不处理。</p><p>event.target 引用了产生此event对象的dom 节点，而event.currrentTarget 则引用了当前处理节点，我们可以 两个target 是否相等</p><p>比如span 点击事件，产生一个event 事件对象，event.target 指向了span元素，span处理此事件时，event.currentTarget<br>指向的也是span元素，这时判断两者相等，则执行相应的处理函数。而事件传递给div2 的时候，event.currentTarget变成 div2，<br>这时候判断二者不相等，即事件不是div2 本身产生的，就不作响应处理逻辑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">方法二</span><br><span class="line">&lt;span style=&quot;font-family:Microsoft YaHei;font-size:10px;&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function() &#123;</span><br><span class="line">document.getElementById(&quot;box1&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">if(event.target == event.currentTarget)</span><br><span class="line">&#123;</span><br><span class="line">alert(&quot;您好，我是最外层div。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementById(&quot;box2&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">if(event.target == event.currentTarget)</span><br><span class="line">&#123;</span><br><span class="line">alert(&quot;您好，我是内层div。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">document.getElementById(&quot;span&quot;).addEventListener(&quot;click&quot;,function(event)&#123;</span><br><span class="line">if(event.target == event.currentTarget)</span><br><span class="line">&#123;</span><br><span class="line">alert(&quot;没错，我就是span。&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>优缺点：</p><p>方法一缺点：为了实现点击特定的元素显示对应的信息，方法一要求每个元素的子元素也必须终止事件的冒泡传递，即跟别的元素功能上强关联，这样的方法会很脆弱。比如，如果span 元素的处理函数没有执行冒泡终止，则事件会传到div2上，这样会造成div2 的提示信息；</p><p>方法二缺点：方法二为每一个元素都增加了事件监听处理函数，事件的处理逻辑都很相似，即都有判断 if(event.target == event.currentTarget)，这样存在了很大的代码冗余，现在是三个元素还好，当有10几个，上百个又该怎么办呢？还有就是为每一个元素都有处理函数，<br>在一定程度上增加逻辑和代码的复杂度。</p><p>既然事件是冒泡传递的，那可不可以让某个父节点统一处理事件，通过判断事件的发生地（即事件产生的节点），然后做出相应的处理呢？答案是可以的，下面通过给body 元素添加事件监听，然后通过判断event.targe然后对不同的target产生不同的行为</p><p>重构方法二的代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    window.onload = function() &#123;</span><br><span class="line">        document.getElementById(&quot;body&quot;).addEventListener(&quot;click&quot;,eventPerformed);</span><br><span class="line">    &#125;;</span><br><span class="line">    function eventPerformed(event) &#123;</span><br><span class="line">        var target = event.target;</span><br><span class="line">        switch (target.id) &#123;</span><br><span class="line">        case &quot;span&quot;:</span><br><span class="line">            alert(&quot;没错，我就是传说中的span。&quot;);</span><br><span class="line">        break;</span><br><span class="line">        case &quot;box1&quot;:</span><br><span class="line">            alert(&quot;您好，我是最外层div。&quot;);</span><br><span class="line">        break;</span><br><span class="line">        case &quot;box2&quot;:</span><br><span class="line">        alert(&quot;您好，我是内层div。&quot;);</span><br><span class="line">        break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>事件冒泡有什么作用？</p><p>事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情</p>]]></content>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>call和apply的区别以及他们的用法</title>
      <link href="/call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E7%94%A8%E6%B3%95-1.html"/>
      <url>/call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E7%94%A8%E6%B3%95-1.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>call和apply的区别以及他们的用法</title>
      <link href="/call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E7%94%A8%E6%B3%95.html"/>
      <url>/call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E7%9A%84%E7%94%A8%E6%B3%95.html</url>
      <content type="html"><![CDATA[<p>call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，<br>就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」<br>以及「上下文是可以改变的」这样的概念。二者的作用完全一样，只是接受参数的方式不太一样。<br>例如，有一个函数 func1 定义如下：var func1 = function(arg1, arg2) {};就可以通过 func1.call(this, arg1, arg2);<br>或者 func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，<br>call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。JavaScript 中，某个函数的参数数量是不固定的，<br>因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。<br>当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。</p>]]></content>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>javacript原型原型链继承</title>
      <link href="/javacript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.html"/>
      <url>/javacript%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>Angular4 表单验证</title>
      <link href="/Angular4-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html"/>
      <url>/Angular4-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>前端性能优化有哪些</title>
      <link href="/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B.html"/>
      <url>/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B.html</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>git</title>
      <link href="/git.html"/>
      <url>/git.html</url>
      <content type="html"><![CDATA[<p> 1.git.fetch和merge和pull的区别</p><pre><code>pull相当于git fetch 和 git merge，即更新远程仓库的代码到本地仓库，然后将内容合并到当前分支。git fetch：相当于是从远程获取最新版本到本地，不会自动mergegit merge :  将内容合并到当前分支git pull：相当于是从远程获取最新版本并merge到本地</code></pre><ol start="2"><li><p>tag</p><p>tag指向一次commit的id，通常用来给开发分支做一个标记<br>打标签 : git tag -a v1.01 -m “Relase version 1.01”<br>提交标签到远程仓库 :  git push origin –tags<br>查看标签 : git tag<br>查看某两次tag之间的commit：git log –pretty=oneline tagA..tagB<br>查看某次tag之后的commit: git log –pretty=oneline tagA..</p></li><li><p>Git和SVN的区别</p><p>Git是分布式版本控制系统，SVN是集中式版本控制系统</p><p>4.Git工作流程</p><ul><li>在工作目录中修改某些文件</li><li>对修改后的文件进行快照，然后保存到暂存区域</li><li>提交更新，将保存在暂存区域的文件快照永久转储到Git目录中</li></ul></li><li><p>常用命令</p><ul><li>git show # 显示某次提交的内容 git show $id</li><li>git add <file> # 将工作文件修改提交到本地暂存区</file></li><li>git rm <file> # 从版本库中删除文件</file></li><li>git reset <file> # 从暂存区恢复到工作文件</file></li><li>git reset HEAD^ # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</li><li>git diff <file> # 比较当前文件和暂存区文件差异 git diff</file></li><li>git log -p <file> # 查看每次详细修改内容的diff</file></li><li>git branch -r # 查看远程分支</li><li>git merge <branch> # 将branch分支合并到当前分支</branch></li><li>git stash # 暂存</li><li>git stash pop #恢复最近一次的暂存</li><li>git pull # 抓取远程仓库所有分支更新并合并到本地</li><li>git push origin master # 将本地主分支推到远程主分支</li></ul></li></ol>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Promise</title>
      <link href="/Promise.html"/>
      <url>/Promise.html</url>
      <content type="html"><![CDATA[<p>Promise 对象是ES6新增的对象，她得作用是网络请求，是异步编程的一种解决方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise((reslove, reject) =&gt; &#123;</span><br><span class="line">    if (resolve) &#123;</span><br><span class="line">        // resolve</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // reject</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then((v) =&gt; &#123;</span><br><span class="line">    // success</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    // error</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>案例(面试题):</p><p>怎么解决回调函数里面回调另一个函数，另一个函数的参数需要依赖这个回调函数。需要被解决的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$http.get(url).success((res) =&gt; &#123;</span><br><span class="line">    if (success != res) &#123;</span><br><span class="line">        success(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).error((res) =&gt; &#123;</span><br><span class="line">    if (error != undefined ) &#123;</span><br><span class="line">        error(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">success = (data) =&gt; &#123;</span><br><span class="line">    if (data.id !=0 ) &#123;</span><br><span class="line">        var url = &quot;getdata/data?id=&quot; + data.id + &quot;&quot;;</span><br><span class="line">            $http.get(url).success(function (res) &#123;</span><br><span class="line">              showData(res);</span><br><span class="line">            &#125;).error(function (res) &#123;</span><br><span class="line">              if (error != undefined) &#123;</span><br><span class="line">                error(res);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请问下面代码一次输出什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;, 0);</span><br><span class="line">new Promise(function executor(resolve) &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  for (var i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">    i == 9999 &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(5);</span><br></pre></td></tr></table></figure><p>// 2、3、5、4、1<br>// 首先定时器会最后执行,Promise是一个异步对象，会先执行所以会输出 2、3 ,<br>// 然后，Promise 的 then 应当会放到当前 tick 的最后，但是还是在当前 tick 中,<br>// 因此，应当先输出 5，然后再输出 4 ， 最后在到下一个 tick，就是 1 。</p><p>promise只有2个状态，成功和失败，怎么让一个函数无论成功还是失败都能被调用？</p><p>使用promise.all() // Promise.all方法的参数可以不是数组,但必须具有Iterator接口，且返回的每个成员都是Promise实例</p><p>Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><p>分析下面这段代码，会输出什么内容::<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const promise1 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    resolve(&apos;success&apos;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const promise2 = promise1.then(() =&gt; &#123;</span><br><span class="line">  throw new Error(&apos;error!!!&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(&apos;promise1&apos;, promise1)</span><br><span class="line">console.log(&apos;promise2&apos;, promise2)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;promise1&apos;, promise1)</span><br><span class="line">  console.log(&apos;promise2&apos;, promise2)</span><br><span class="line">&#125;, 2000)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">promise1 Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">promise2 Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">(node:50928) UnhandledPromiseRejectionWarning: Unhandled promise rejection (rejection id: 1): Error: error!!!</span><br><span class="line">(node:50928) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.</span><br><span class="line">promise1 Promise &#123; &apos;success&apos; &#125;</span><br><span class="line">promise2 Promise &#123;</span><br><span class="line">  &lt;rejected&gt; Error: error!!!</span><br><span class="line">    at promise.then (...)</span><br><span class="line">    at &lt;anonymous&gt; &#125;</span><br></pre></td></tr></table></figure></p><p>原因：<br>promise 有 3 种状态：pending（进行中）、fulfilled（已完成，又称为Resolved） 或 rejected（已失败）。状态改变只能是 pending-&gt;fulfilled 或者 pending-&gt;rejected，状态一旦改变则不能再变。上面 promise2 并不是 promise1，而是返回的一个新的 Promise 实例。</p>]]></content>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Angular-cli常用命令</title>
      <link href="/Angular-cli%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
      <url>/Angular-cli%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
      <content type="html"><![CDATA[<p>angular/cli 常用命令:</p><pre><code>- ng server // 启动服务- ng g component  // 创建组件- ng g pipe // 创建管道- ng g service // 创建服务- ng g directive // 创建指令- ng build // 编译打包</code></pre><p> 参数:</p><pre><code>- --flat // 不在自用的目录内创建代码- --route=&lt;route&gt; // 指定父路由.仅用于生成组件和路由.默认为指定的路径- --skip-router-generation // 跳过生成父路由配置。只能用于路由命令。- --defasult // 指定路由应为默认路由。- lazy  // 指定路由是延迟的。 默认为true。</code></pre><p> 生产构建</p><pre><code>- ng build --target=production --environment=prod- ng build --prod --env=prod- ng build --pr</code></pre><p> 开发构建</p><pre><code>- ng build --target=development --environment=dev- ng build --dev --e=dev- ng build --dev- ng build</code></pre><p> 自定义指定启动端口号和地址</p><pre><code>- ng serve --host 0.0.0.0 --port 4201 --live-reload-port 49153</code></pre>]]></content>
      
      
        <tags>
            
            <tag> angular-cli </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>创建一个原生的Ajax与jsonp封装的Ajax</title>
      <link href="/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8E%9F%E7%94%9F%E7%9A%84Ajax%E4%B8%8Ejsonp%E5%B0%81%E8%A3%85%E7%9A%84Ajax.html"/>
      <url>/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8E%9F%E7%94%9F%E7%9A%84Ajax%E4%B8%8Ejsonp%E5%B0%81%E8%A3%85%E7%9A%84Ajax.html</url>
      <content type="html"><![CDATA[<p>原生:</p><ul><li><p>首先我们要知道什么是Ajax，以及如何创建一个Ajax和他是怎样调用服务的？</p><ul><li>创建XMLHTTPRequest 对象</li><li>创建一个新的http对象，并指定请求方法类型、验证信息</li><li>设置HTTP请求状态变化的回调函数</li><li>发送http请求</li><li>获取异步调用返回的数据</li><li>使用javascript和DOM实现局部刷新</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&quot;POST&quot;, url, true);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;)</span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; (xhr.status == 200 || xhr.status == 304)) &#123;</span><br><span class="line">        fn.call(this.xhr.responseText);</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>jsonp:</p><p>实现资源跨域访问请求数据</p>]]></content>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5新特性总结</title>
      <link href="/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.html"/>
      <url>/HTML5%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p>本地存储 localStorage sessionStorage<br>离线应用 mainfest<br>桌面通知 Notifications<br>语义化标签 section header nav footer<br>地理位置 Geolocation<br>多任务 webworker<br>跨域资源(CORS)<br>绘画 Canvas<br>拖拽释放(Dray and drop)API<br>媒体 (video) (audio)<br>双工程通讯协议(webscoket)</p>]]></content>
      
      
        <tags>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浏览器多个标签之间通讯</title>
      <link href="/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF.html"/>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E4%B8%AA%E6%A0%87%E7%AD%BE%E4%B9%8B%E9%97%B4%E9%80%9A%E8%AE%AF.html</url>
      <content type="html"><![CDATA[<p>第一种:</p><p>在一个标签中使用localStorage.setItem(key,value)//添加内容<br>在另一个标签里监听storage事件<br>及可得到 localStorge存储的值，实现不同标签只见那的通讯</p><p>标签一:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;</span><br><span class="line">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;srcipt&gt;</span><br><span class="line">    $(function () &#123;</span><br><span class="line">        $(&apos;#btn&apos;).click(function() &#123;</span><br><span class="line">            var name = $(&apos;#name&apos;).val();</span><br><span class="line">            locastorage.setItem(&apos;name&apos;: name);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>标签二:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(function() &#123;</span><br><span class="line">        window.addEventListener(&apos;storage&apos;, function(e) &#123;</span><br><span class="line">             console.log(e.key  + e.newVlaue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>第二种:</p><p>页面一:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;name&quot;&gt;</span><br><span class="line">&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(function() &#123;</span><br><span class="line">        $(&apos;#btn&apos;).click(function() &#123;</span><br><span class="line">            var name = $(&apos;#name&apos;).val();</span><br><span class="line">            document.cookie = &apos;name&apos;+name;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>页面二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(function() &#123;</span><br><span class="line">        function getCookie(key) &#123;</span><br><span class="line">            return JSON.parse(&quot;&#123;\&quot;&quot; + document.cookie.replace(/;\s+/gim,&quot;\&quot;,\&quot;&quot;).replace(/=/gim, &quot;\&quot;:\&quot;&quot;) + &quot;\&quot;&#125;&quot;)[key]</span><br><span class="line">        &#125;</span><br><span class="line">        setInterval(function() &#123;</span><br><span class="line">            console.log(&apos;name=&apos;+getCookie(&apos;name&apos;));</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> cookies localStorag </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Angular4组件之间的传值</title>
      <link href="/Angular4%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC.html"/>
      <url>/Angular4%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BC%A0%E5%80%BC.html</url>
      <content type="html"><![CDATA[<p>组件之间传值</p><p>通过Input、Output</p>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular4生命周期函数</title>
      <link href="/angular4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.html"/>
      <url>/angular4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0.html</url>
      <content type="html"><![CDATA[<p>今天去面试，被问到angular4的生命周期函数，自己明明知道的，瞬间脑子一片空白 ….</p><p>现在总结如下:</p><p>ngOnInit<br>    组件初始化时后调用,只会调用一次(在第一次ngOnChanges后调用)</p><p>ngOnChanges<br>    在有输入属性的情况下才会被调用</p><p>ngDoCheck<br>    在组件定义的属性或方法变更时调用,用于脏值之间的检测，由于非常消耗性能，(他会把所有的属性和方法都检测一遍)，<br>    他会在ngChanges,ngOninit后执行</p><p>ngAfterContentInit<br>    组件内容初始化之后调用，第一次ngDeCheck之后调用，只会调用一次</p><p>ngAfterContentChecked<br>    在组件每次检查内容发生变更时调用，在ngAfterContentInit和每次ngDoCheck之后调用</p><p>ngAfterViewInit<br>    在组件相对应的视图初始化之后调用，在ngAfterConetntCheck之后调用,只会调用一次</p><p>ngAfterViewChecked<br>    组件每次检查视图初始化之后调用</p><p>ngOnDestroy<br>    最后执行,做一些销毁、清理工作(比如说清理清理定时器，移除事件监听，事件退订)</p><p>吸取经验教训,总结…</p>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular4 Output</title>
      <link href="/angular4-Output.html"/>
      <url>/angular4-Output.html</url>
      <content type="html"><![CDATA[<p>angular输出属性output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input, Output, EventEmitter &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;zn-counter&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line"></span><br><span class="line">    constructor ()&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Input () count: number: 0;</span><br><span class="line"></span><br><span class="line">    @Output() change: EventEmintter&lt;number&gt; = new EventEmintter&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">    icrement() &#123;</span><br><span class="line">        this.count ++;</span><br><span class="line">        this.change.emit(this.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement() &#123;</span><br><span class="line">        this.count --;</span><br><span class="line">        this.change.emint(this.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular知识总结</title>
      <link href="/angular%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html"/>
      <url>/angular%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93.html</url>
      <content type="html"><![CDATA[<p>1、angular 是mvc还是mvvm框架 ？</p><pre><code>答案是肯定的.首先我们来说说什么是mvc，它是由视图、控制器、数据，三者所组成的，mvvm是对mvc的进一步升级，把Controller的数据和逻辑处理部分从中抽离出来，用一个专门的对象去管理，这个对象就是ViewModel，是Model和Controller之间的一座桥梁。    优点:        1.Controller清晰简洁： ViewModel分离了大部分Controller代码，更加清晰和容易维护。        2.方便测试：开发中大部分Bug来至于逻辑处理，由于ViewModel分离了许多逻辑，可以对ViewModel构造单元测试。        3.开发解耦(举两个例子)：                a.一人负责逻辑实现、另一人负责UI实现；                b.敏捷开发时，会发经常发不是等后端做好了接口我们再去开发，不过在没有接口的情况下通常我们可以把Controller和View完成。    缺点:         1.看起来代码会比MVC多点         2.需要对每个Controller实现绑定，如果处理不好，反而会有一种“画虎不成反类犬”的感觉</code></pre>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular4输入属性(Input)</title>
      <link href="/angular4%E8%BE%93%E5%85%A5%E5%B1%9E%E6%80%A7-Input.html"/>
      <url>/angular4%E8%BE%93%E5%85%A5%E5%B1%9E%E6%80%A7-Input.html</url>
      <content type="html"><![CDATA[<p>Input 是输入属性,用来定义组件的内的输入属性，主要用来实现父组件想子组件传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;dex-counter&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class CounterComponent &#123;</span><br><span class="line"></span><br><span class="line">    // 变量</span><br><span class="line">    _count: number = 0;</span><br><span class="line">    biggerThanTen: boolean = false;</span><br><span class="line"></span><br><span class="line">    constrcutor() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Input(&apos;value&apos;) count: number = 0;</span><br><span class="line"></span><br><span class="line">    // set</span><br><span class="line">    @Input()</span><br><span class="line">    set count(num: number) &#123;</span><br><span class="line">        this.biggerThanTen = num &gt; 10;</span><br><span class="line">        this._count = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get count():number &#123;</span><br><span class="line">        return this._count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ngOnChanges</p>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular4中ngOnInit与contrutor的用法详解</title>
      <link href="/angular4%E4%B8%ADngOnInit%E4%B8%8Econtrutor%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
      <url>/angular4%E4%B8%ADngOnInit%E4%B8%8Econtrutor%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
      <content type="html"><![CDATA[<p>想必大家都不陌生constructor构造函数,这是ES6中引入的<br>在angulaur中constructor一般的作用，我们会再其中依赖注入,初始化默认值等操作。</p><p>ngOnInit</p><pre><code>ngOnInit 用于在 Angular 获取输入属性后初始化组件，该钩子方法会在第一次 ngOnChanges 之后被调用注意: 该钩子只会被调用一次.</code></pre><p>parent.component.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> import &#123; Component &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line"> @Component(&#123;</span><br><span class="line">    selector: &apos;exe-parent&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class ParentComponent &#123;</span><br><span class="line"></span><br><span class="line">    private name: &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.name = &apos;LiMing&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>child.component.ts</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, Input, OnInit &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">    selector: &apos;exe-child&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class ChildComponent implements OnInit &#123;</span><br><span class="line">    @Input()</span><br><span class="line">    pname: string; // 父组件的名称</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        console.log(&apos;constructor \&apos; + this.pname) // undefined</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ngOnInit () &#123;</span><br><span class="line">        console.log(&apos;ngOnInit \&apos; + this.pname) // LiMing</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现在 ChildComponent 构造函数中，是无法获取输入属性的值，而在 ngOnInit 方法中，我们能正常获取输入属性的值。因为 ChildComponent 组件的构造函数会优先执行，当 ChildComponent 组件输入属性变化时会自动触发 ngOnChanges 钩子，然后在调用 ngOnInit 钩子方法，所以在 ngOnInit 方法内能获取到输入的属性。</p><p>constructor应用场景</p><pre><code>依赖注入，初始化值</code></pre><p>ngOnInit 应用场景</p><pre><code>在组件获取输入属性之后，需执行组件初始化操作</code></pre><p>总结:</p><p>在 Angular 4 中 constructor 一般用于依赖注入或执行简单的数据初始化操作，ngOnInit 钩子主要用于执行组件的其它初始化操作或获取组件输入的属性值</p>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular2 VS angular4 对比: 特性、性能</title>
      <link href="/angular2-VS-angular4-%E5%AF%B9%E6%AF%94-%E7%89%B9%E6%80%A7%E3%80%81%E6%80%A7%E8%83%BD.html"/>
      <url>/angular2-VS-angular4-%E5%AF%B9%E6%AF%94-%E7%89%B9%E6%80%A7%E3%80%81%E6%80%A7%E8%83%BD.html</url>
      <content type="html"><![CDATA[<p>Angular2是在2015年底发布的。接下来一起了解Angular2这个版本发布的原因以及如何将其添加到Web开发中。</p><p>这个Angular版本更加注重于开发移动应用程序，开发人员可以使用它创建跨平台的应用程序，在解决了移动应用程序（功能，加载时间等）的挑战后，Angular2可以更容易的处理桌面组件。</p><p>许多模块被淘汰出了Angular核心，这也促使Angular2具备更好的性能。Angular走向了不断增长的模块生态系统，这意味着开发者可以自由的选择所需的组件。</p><p>Angular 2.0基于ES6标准和“evergreen”现代浏览器（可自动更新到最新版本的浏览器）。在这些浏览器上构建应用，意味着可以更容易的使用Angular进行开发和优化，从而允许开发人员更专注于公司业务实现的代码。</p><p>Angular2 的特性和性能<br>AtScript是ES6的超集，用于帮助Angular2的开发。它由Traceur编译器（结合ES6）进行处理，然后生成ES5代码，并使用TypeScript语法创建运行时类型断言。但是，AtScript不是强制性的，开发人员仍然可以选择只使用纯JavaScript / ES5代码来构建Angular应用程序。</p><p>提升依赖注入（DI）：<br>依赖注入（一种程序设计模式，可以通过依赖关系实现调用，而不需要生成）是一种Angular显著区别于其竞争对手的特性。依赖注入在模块化开发和元素隔离方面非常有帮助，但它的实现一直受到Angular 1.x的困扰。Angular2解决了这个问题，另外还添加了一些缺少的功能，如子注入以及生命周期/范围控制。</p><p>注解：<br>AtScript提供了连接元数据和功能的工具。通过在DI库中提供基本信息（可以调用函数或创建类的实例来检查相关元数据），从而简化了对象实例的构建。通过提供注入注释，使得参数信息重写也变得简单。</p><p>子注入：<br>子注入继承了其父级注入所有的专业服务，以及在子层次重写的能力。根据需要，在一定范围内，一些类型的对象可以被调用和机械的重写。</p><p>实例范围：<br>增强的DI库是由实例范围控制器组成的，当与子注入器连同范围标识符一起使用时，会更加强大。</p><p>动态载入：<br>这是之前的Angular版本均不具备的功能，Angular2包含了这个功能，即使在开发人员忙碌时，也能够添加新的指令或控件。</p><p>模板：<br>在Angular2中，模板编译过程是异步的。由于代码依赖于ES6模块，因此模块加载程序将通过在部分组件上引用它们，来加载依赖关系。</p><p>指令：<br>Angular2提供了三种指令：</p><p>组件指令：通过将逻辑封装在HTML，CSS和JavaScript中，从而使得组件可复用。<br>装饰器指令：可用于装饰元素（例如，通过隐藏/显示元素ng-hide/ng-show或添加工具提示）。<br>模板指令：可以将HTML转换为可复用的模板。该模板的实例化以及插入到DOM过程可以完全由指令创建者控制。例如ng-repeat和ng-if。</p><p>子路由<br>子路由将通过提供自身的路由功能，将程序的每个部分转换为更紧密的应用程序，这有助于整个程序功能集合的封装。</p><p>Screen Activator：<br>通过Angular 2，开发人员可以通过一系列can *回调对导航生命周期进行更好的控制。</p><p>canActivate：它允许或阻止导航到新的控件。<br>激活：它会响应导航到新控件的成功事件。<br>canDeactivate：它将防止或允许跳出旧控制器的导航。<br>停用：它会响应跳出旧控制器的成功事件。</p><p>设计：<br>所有这些逻辑都是使用管道架构创建的，这使得将自己的操作添加到管道中或删除默认操作变得非常简单。此外，它的异步字符允许开发人员在管道中，实现对用户进行身份验证或加载控件信息的服务器请求。</p><p>记录：<br>Angular 2.0包括一个名为diary.js的日志记录服务，这是一个非常有用的属性，用于测量开发人员的编码投入时间（从而允许开发人员识别代码中的瓶颈）。</p><p>scope：<br>$scope 从Angular2中删除了。</p><p>Angular4</p><p>Angular4 的特性和性能<br>相比于Angular 2，Angular4的功能列表中添加了许多新功能，同时还有一些旧功能的改进。</p><p>更小更快：<br>使用Angular4，程序将会消耗更少的空间，并比以前的版本运行地更快。工作主要用于不断进行改进。</p><p>视图引擎：<br>Angular4的开发人员修改了视图引擎的代码，例如AOT创建的代码。这些修改促使视图部分生成的代码大小减少了大约60％。模板越是复杂，节省的就越多。</p><p>动画包：<br>Angular4的开发人员将动画从Angular的核心部分提取出来，并将它们放在独立的包中。这意味着如果开发人员不需要使用动画，就可以不创建这些额外的代码。</p><p>这个功能还能够帮助更方便的查找docs文件和使用自动完成功能。开发人员可以通过为@angular/platform-b​​rowser/animations引入浏览器动画模块，从而实现为主要的NgModule添加动画功能。</p><p>改进 <em>ngIf 和 </em>ngFor：<br>模板绑定语法目前支持一些少量有帮助的更改。现在，开发人员已经可以使用if/else设计​​语法，并分配局部变量了。</p><p>Angular Universal：<br>此版本是Universal团队几个月的工作成果。这个Universal版本的代码的绝大多数目前位于@angular/platform-server。</p><p>TypeScript 2.1和2.2兼容性：<br>Angular4开发组将Angular升级为更新版本的TypeScript。这将提高ngc的速度，方便开发人员将在编码过程中更好的进行类型检查。</p><p>模板的源映射：<br>每当模板中的某些内容出现错误时，都将创建源映射，为原始模板提供有意义的说明内容。</p><p>结论：<br>对于仍处于学习阶段的人来说，Angular会有点混乱。但对于具有Angular2知识的有经验的开发人员来说，会觉得Angular很容易使用，并且使用Angular对项目非常有帮助。</p><p>原文地址: <a href="https://dzone.com/articles/angular-2-vs-angular-4-features-performance" target="_blank" rel="noopener">https://dzone.com/articles/angular-2-vs-angular-4-features-performance</a></p>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular4 Directive Lifecycle</title>
      <link href="/angular4-Directive-Lifecycle.html"/>
      <url>/angular4-Directive-Lifecycle.html</url>
      <content type="html"><![CDATA[<p>angular 指令(Directive)组件(Component)的关系:</p><pre><code>- Component 继承(extends) Directive- (组价) Component 是 (指令)Directive 的组成部分</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export interface Directive &#123;</span><br><span class="line">   selector?: string;  // 用于定义组件在HTML代码中匹配的标签</span><br><span class="line">   inputs?: string[];  // 指令的输入属性</span><br><span class="line">   outputs?: string[];  // 指令的输出属性</span><br><span class="line">   host?: &#123;[key: string]: string&#125;;  // 绑定宿主的属性、事件等</span><br><span class="line">   providers?: Provider[];  // 设置指令及其子指令可以用的服务</span><br><span class="line">   exportAs?: string;  // 导出指令，使得可以在模板中调用</span><br><span class="line">   queries?: &#123;[key: string]: any&#125;;  // 设置指令的查询条件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface Component extends Directive &#123;</span><br><span class="line">   changeDetection?: ChangeDetectionStrategy;  // 指定组件使用的变化检测策略</span><br><span class="line">   viewProviders?: Provider[];     // 设置组件及其子组件(不含ContentChildren)可以用的服务</span><br><span class="line">   moduleId?: string;  // 包含该组件模块的 id，它被用于解析 模版和样式的相对路径</span><br><span class="line">   templateUrl?: string;  // 为组件指定一个外部模板的URL地址</span><br><span class="line">   template?: string;  // 为组件指定一个内联的模板</span><br><span class="line">   styleUrls?: string[];  // 为组件指定一系列用于该组件的样式表文件</span><br><span class="line">   styles?: string[];  // 为组件指定内联样式</span><br><span class="line">   animations?: any[];  // 设置组件相关动画</span><br><span class="line">   encapsulation?: ViewEncapsulation;  // 设置组件视图包装选项</span><br><span class="line">   interpolation?: [string, string];  // 设置默认的插值运算符，默认是&quot;&#123;&#123;&quot;和&quot;&#125;&#125;&quot;</span><br><span class="line">   entryComponents?: Array&lt;Type&lt;any&gt;|any[]&gt;;  // 设置需要被提前编译的组件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>指令与组件共有的钩子</p><ul><li>ngOnChanges // 当数据绑定输入属性的值发生变化时调用 (1)</li><li>ngOnInit // 在第一次 ngChanges 后调用 (2)</li><li>ngDoCheck // 自定义的方法，用于检测和处理值的改变 (3)</li><li>ngOnDestory // 指令销毁前调用 (8)</li></ul></li><li><p>组件特有的钩子</p><ul><li>ngAfterContentInit // 在组件内容初始化之后调用 (4)</li><li>ngAfterContentChecked // 组价每次检查内容时调用 (5)</li><li>ngAfterViewInit // 组件相应的视图初始化之后调用 (6)</li><li>ngAfterViewChecked // 组件每次检查视图时调用 (7)</li></ul></li></ul><p>constructor 构造函数</p><pre><code>组件的生命周期函数会在所有生命周期钩子调用之前调用， 一般初始化数据，或者依赖注入用.</code></pre><p>ngOnChanges</p><pre><code>当数据绑定输入属性的值发生改变时，Angular会主动调用ngOnChanges方法, 他会获得一个SimpleChanges对象，包含绑定的旧值新值，用于检测组件的输入属性的变化.</code></pre><p>ngOnInit(只会被调用一次)</p><pre><code>在ngOnChanges执行之后，会调用ngOnInit， 执行组件的其他操作或获取组件输入属性的值。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: &apos;my-app&apos;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;h1&gt;Welcome to Angular World&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Hello &#123;&#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">export class AppComponent implements OnInit &#123;</span><br><span class="line"></span><br><span class="line">  name: string = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(&apos;Constructor initialization&apos;);</span><br><span class="line">    this.name = &apos;Semlinker&apos;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ngOnInit() &#123;</span><br><span class="line">    console.log(&apos;ngOnInit hook has been called&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出的结果为:</span><br><span class="line">    Constructor initialization</span><br><span class="line">    ngOnInit hook has been called</span><br></pre></td></tr></table></figure><p>ngOnDestory</p><pre><code>在指令被销毁前调用，用于清理操作,比如: 清理定时器,移除事件监听、退订Observable等</code></pre><p>ngDoCheck</p><pre><code>在组件的输入属性发生变化时触发，自定义我们的检测逻辑。它也可以用来加速我们变化检测的速度</code></pre><p>ngAfterContenInit</p><pre><code>在组件使用 ng-content 指令的情况下，Angular 会在将外部内容放到视图后用它主要用于获取通过 @ContentChild 或 @ContentChildren 属性装饰器查询的内容视图元素</code></pre><p>ngAfterContentChecked</p><pre><code>在组件使用 ng-content 指令的情况下，Angular 会在检测到外部内容的绑定或者每次变化的时候调用</code></pre><p>ngAfterViewInit</p><pre><code>在组件相应的视图初始化之后调用，它主要用于获取通过 @ViewChild 或 @ViewChildren 属性装饰器查询的视图元素</code></pre><p>ngAfterViewChecked</p><pre><code>组件每次检查视图时调用</code></pre>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular4 指令</title>
      <link href="/angular4-%E6%8C%87%E4%BB%A4.html"/>
      <url>/angular4-%E6%8C%87%E4%BB%A4.html</url>
      <content type="html"><![CDATA[<p>angular 4 中指令分为以下三种</p><ul><li><p>组件(Component directive): 用于构建UI组件，集成Directive类<br>  例如: ngStyle 、ngClass</p></li><li><p>属性指令(Attrbute directive): 用于改变组件的外观或者行为<br>  例如: ngIf、 ngFor、ngSwitch</p></li><li><p>结构指令(Structural directive): 用于动态添加删除DOM元素来改变DOM布局</p></li></ul><p>自定义属性指令实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Directive, Input, ElementRef, Renderer, HostListener&#125; from &apos;@angular/core&apos;;</span><br><span class="line"></span><br><span class="line">@Directive(&#123;</span><br><span class="line">    seletor: &apos;[exeBackground]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class exeBackground &#123;</span><br><span class="line">    private _defaultColor = &apos;red&apos;;</span><br><span class="line"></span><br><span class="line">    @Input(&apos;exeBackground&apos;)</span><br><span class="line">    backgroundColor: string; // 输入属性，用于设置元素的背景颜色</span><br><span class="line"></span><br><span class="line">    construtor(private elementRef: ElementRef,</span><br><span class="line">        private renderer: Renderer</span><br><span class="line">    ) &#123;</span><br><span class="line">        this.setStyle(this._defaultColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HostListener(&apos;click&apos;)</span><br><span class="line">    onClick() &#123;</span><br><span class="line">    // 监听宿主的点击事件，设置元素的背景</span><br><span class="line">    this.setStyle(this.backgroundColor || this._defaultColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private setStyle(style: string) &#123;</span><br><span class="line">        // 调用rendener对象提供的API设置元素的背景颜色</span><br><span class="line">        this.rendener.setElementStyle(this.element.nativeElement,</span><br><span class="line">            &apos;backgroundColor&apos;, color</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自定义结构型指令实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ... &#125; from &quot;@angular/core&quot;;</span><br><span class="line"></span><br><span class="line">@directive(&#123;</span><br><span class="line">    selector: &apos;[exeUnClass]&apos;</span><br><span class="line">&#125;)</span><br><span class="line">export class UnClassDirective &#123;</span><br><span class="line">    @Input(&apos;exeUnClass&apos;)</span><br><span class="line">    set condition(newCondition: boolean) &#123;</span><br><span class="line">        if (!newCondition) &#123;</span><br><span class="line">            this.viewContainer.createEmbeddedView(this.templateRef)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.viewContainer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(private templateRef: TemplateRef&lt;any&gt;,</span><br><span class="line">        private viewContainer: ViewContainerRef</span><br><span class="line">    ) &#123;</span><br><span class="line">        // code...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo next主题安装algolia</title>
      <link href="/Hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85algolia.html"/>
      <url>/Hexo-next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85algolia.html</url>
      <content type="html"><![CDATA[<p>一直在使用hexo写自己的博客,最近博客刚刚搬家重新搞了下博客:</p><p>1、为hexo添加站内搜索</p><p>我用的是algolia,在next主题5.x以上的版本集成了algolia站内搜索功能，我们只需要简单的配置下就可以使用:<br>安装:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-algolia --save</span><br></pre></td></tr></table></figure></p><p>配置:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: &apos;your applicationID&apos;</span><br><span class="line">  apiKey: &apos;your apiKey&apos;</span><br><span class="line">  adminApiKey: &apos;your adminApiKey&apos;</span><br><span class="line">  indexName: &apos;your indexName&apos;</span><br><span class="line">  chunkSize: 500</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">设置好之后，执行下面的语句:</span><br></pre></td></tr></table></figure></p><p>hexo clean<br>hexo algolia<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在修改NexT主题集成Algolia,打开them下面的_config.xml配置文件,增加如下配置:</span><br></pre></td></tr></table></figure></p><p>algolia: true<br><code>`</code></p>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> algolia </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次temcat安装</title>
      <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1temcat%E5%AE%89%E8%A3%85.html"/>
      <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1temcat%E5%AE%89%E8%A3%85.html</url>
      <content type="html"><![CDATA[<p>今天开始学习java,看了很多也想动手去写写代码。 于是乎看到网上的教程用javaee和Temcat写一个后台接口，也方便日后去写前端的时候去写点数据方便测试;</p><p>说的再多不如开始动手写起来,简单的看了下java的语法,可以看懂。现在我要在本机电脑上安装Temcat服务器,它是免费开源的。数据库mysql安装<a href="https://zristart.github.io/2018/06/14/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/#more">上篇文章</a> 不会的小伙伴可以看哈。 现在我们开始安装<a href="https://tomcat.apache.org/download-70.cgi" target="_blank" rel="noopener">Temcat</a>去找对应版本下载，我这里所使用的是7.x的，下载完成后到你的本地目录找到对应的文件，解压缩，找到../bin文件夹下的 startup.bat 双击打开即可使用。</p><p>未完待续。</p>]]></content>
      
      
        <tags>
            
            <tag> temcat </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记一次mysql安装过程中所踩过的坑</title>
      <link href="/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html"/>
      <url>/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%89%80%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91.html</url>
      <content type="html"><![CDATA[<p>写前端这么久了，想着写写后台，说干就干 首先我的后台是用java语言写 javaweb.</p><p>开始装我们的mysql数据库吧，首先去<a href="https://www.mysql.com/downloads/" target="_blank" rel="noopener">mysql</a>去下载对应的版本开始装机，我所使用的是windows机器, download –&gt; community –&gt; mysql community server 开始下载..</p><p>下载好后，解压下载的压缩包放到你的本地磁盘d中<a href="...">D:\mysql</a> ok, 至此我们的mysql装好了， 现在配置环境<br>在myslq解压的当前目录下新建my.ini文件,开始写我们的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql 默认字符集</span><br><span class="line">default-chartacter-set=uft8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># 设置端口</span><br><span class="line">port = 3306</span><br><span class="line"></span><br><span class="line"># mysql安装目录</span><br><span class="line">basedir=D:\mysql</span><br><span class="line"></span><br><span class="line"># 设置mysql数据库存放位置</span><br><span class="line">datadir = D:\mysql\data</span><br><span class="line"></span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"></span><br><span class="line"># 服务器端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">characset-set-server=utf8</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line"># 快速设置mysql的密码</span><br><span class="line">#skip-grant-tables</span><br></pre></td></tr></table></figure><p>OK,至此mysql的初始化工作已经完成, 现在要将mysql添加到环境变量中去, 具体做法 [D:\mysql] 添加到path中去, 记得用分号隔开;</p><p>安装服务: mysqld install ; 记得是在你的安装mysql目录中bin文件夹内, cmd使用管理员权限;</p><p>环境变量配置完成, 现在我们开启mysql服务  net start mysql </p><p>这时候往往会报这种错误 [mysql服务无法启动 服务没有报告任何错误 ] 那该怎么处理呢？</p><p>OK, 回到之前我们在写配置文件时 datadir=D:\mysql\data 这个, 这里不要手动创建这个data文件夹,使用命令创建<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld  --initialize-insecure</span><br></pre></td></tr></table></figure></p><p>这时候会发现,data目录已经被创建完毕,里面的配置文件也齐全，OK 现在我门开启 mysql </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>这时服务已经启动成功！    </p>]]></content>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ionic3 生命周期钩子</title>
      <link href="/ionic3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.html"/>
      <url>/ionic3-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90.html</url>
      <content type="html"><![CDATA[<h2 id="ionViewDidLoad"><a href="#ionViewDidLoad" class="headerlink" title="ionViewDidLoad"></a>ionViewDidLoad</h2><p>页面加载完成触发，这里的“加载完成”指的是页面所需的资源已经加载完成，但还没进入这个页面的状态（用户看到的还是上一个页面）。</p><p>需要注意的是它是一个很傲娇的钩子，全程只会调用一次，即第一次进入页面时被调用，此后你无论怎样进进出出它都冷冷清清凄凄惨惨戚戚不再理你了。除非你把它的后台杀了，重新进入这个软件（在网页调试的时候按刷新也是可以的）。</p><p>因此这个钩子适合你做一些一次性的处理，比如从服务器拉取用户数据存到缓存中。</p><h2 id="ionViewWillEnter"><a href="#ionViewWillEnter" class="headerlink" title="ionViewWillEnter"></a>ionViewWillEnter</h2><p>字面意义理解就是“我要进来了”的那一刻，这个时候页面刚刚开始切换。你可以在这时对页面的数据进行预处理，这个钩子是每次都会调用的</p><h2 id="ionViewDidEnter"><a href="#ionViewDidEnter" class="headerlink" title="ionViewDidEnter"></a>ionViewDidEnter</h2><p>当这个钩子被触发的时候，用户已经进入到新页面了（页面处于激活状态），同样也是每次都会调用。</p><p>说到这我不得不插一句，ionic对钩子的命名对广大中国学生真是友好啊，一个will一个did就把事情解决了。不像外边某些妖艳（误）的框架，一堆ready, update, complied, destory什么的，记一次忘一次。（当然这是一个玩笑，组件的命名跟框架的运行机制是息息相关的）</p><h2 id="ionViewWillLeave"><a href="#ionViewWillLeave" class="headerlink" title="ionViewWillLeave"></a>ionViewWillLeave</h2><p>页面准备 (is about to) 离开时触发，这时用户刚刚触发了返回按钮或者相关的事件。</p><h2 id="ionViewDidLeave"><a href="#ionViewDidLeave" class="headerlink" title="ionViewDidLeave"></a>ionViewDidLeave</h2><p>页面已经 (has finished) 离开时触发，页面处于非激活状态了。</p><h2 id="ionViewWillUnload"><a href="#ionViewWillUnload" class="headerlink" title="ionViewWillUnload"></a>ionViewWillUnload</h2><p>页面中的资源即将被销毁时触发，此刻你是否会猜测这个钩子与ionViewDidLoad一样，只会被触发一次呢？</p><p>注意:<br>构造函数在ionViewDidLoad之前被触发<br>ionViewDidLoad只在第一次进入页面时触发<br>ionViewWillUnload会在每次离开页面后触发</p><h2 id="守卫钩子"><a href="#守卫钩子" class="headerlink" title="守卫钩子"></a>守卫钩子</h2><h2 id="ionViewCanEnter"><a href="#ionViewCanEnter" class="headerlink" title="ionViewCanEnter"></a>ionViewCanEnter</h2><h2 id="ionViewCanLeave"><a href="#ionViewCanLeave" class="headerlink" title="ionViewCanLeave"></a>ionViewCanLeave</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//和蔼可亲的班主任</span></span><br><span class="line">    ionViewCanEnter() :boolean &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getHours()&gt;=<span class="number">8</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'怎么的呢，你看看现在几点了，你那么舒服咋不在家里接着睡吶，给我门外站着去！'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//杏花楼姿态万千的老鸨</span></span><br><span class="line">    ionViewCanLeave() :boolean &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getHours()&gt;=<span class="number">22</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'哎呀公子，你看都这么晚了，最近外面风声那么紧，不如就在我们这儿留宿吧，你看姑娘们都舍不得你回去呢'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ionViewDidLoad 第一次调用 返回void<br>ionViewWillEnter 每次调用 返回void<br>ionViewDidEnter 每次调用 返回void<br>ionViewWillLeave 每次调用 返回void<br>ionViewDidLeave 每次调用 返回void<br>ionViewWillUnload 每次调用 返回void<br>ionViewCanEnter 每次调用 返回boolean<br>ionViewCanLeave 每次调用 返回boolean</p>]]></content>
      
      
        <tags>
            
            <tag> ionic3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>angular学习之路</title>
      <link href="/angular%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html"/>
      <url>/angular%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF.html</url>
      <content type="html"><![CDATA[<p>中文官网 <a href="https://www.angular.cn" target="_blank" rel="noopener">https://www.angular.cn</a></p>]]></content>
      
      
        <tags>
            
            <tag> Angular </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ionic使用中所遇到的坑</title>
      <link href="/ionic%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html"/>
      <url>/ionic%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%89%80%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91.html</url>
      <content type="html"><![CDATA[<p>总结一下我在使用ionic3中所遇到的问题在这里总结下:</p><ol><li><p>首先最新版ionic在我们构建好项目、启动成功后，修改过文件或者是刷新浏览器的情况下，我们的ionic项目运行在终端的servce会中断<br>这是因为其中一个模块的问题(ws),进入到node_module中删除他，之后在命令行执行 npm install <a href="mailto:ws@3.3.2" target="_blank" rel="noopener">ws@3.3.2</a> –save, 安装完毕后<br>重新启动项目，搞定。</p></li><li><p>在构建服务时，有时候会忘记引入http服务，我们在组建中药引入http模块，同样在app.module.ts中也要引入httpModule模块， 否则会报错。</p></li><li><p>我们在写代码时,常常会遇到跨域问题,解决ionic3跨域问题的方法:<br> 我们找到项目根目录下的ionic.config.json配置文件,在里面添加如下配置</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"proxies"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"path"</span>: <span class="string">"/list"</span>,</span><br><span class="line">      <span class="string">"proxyUrl"</span>: <span class="string">"https://m.toutiao.com/list/"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
        <tags>
            
            <tag> ionic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用Digitalocean搭建SS并使用BBR加速</title>
      <link href="/%E4%BD%BF%E7%94%A8Digitalocean%E6%90%AD%E5%BB%BASS%E5%B9%B6%E4%BD%BF%E7%94%A8BBR%E5%8A%A0%E9%80%9F.html"/>
      <url>/%E4%BD%BF%E7%94%A8Digitalocean%E6%90%AD%E5%BB%BASS%E5%B9%B6%E4%BD%BF%E7%94%A8BBR%E5%8A%A0%E9%80%9F.html</url>
      <content type="html"><![CDATA[<p>服务器: ubuntu 14.01 64<br>本地电脑: ubuntu 16.04 64</p><p>首先我自己本想着买vpn, 但是作为技术出身的我来讲，靠人不如靠己，自己动手风衣足食。</p><p>首先我我选择的是<a href="https://www.digitalocean.com/?refcode=840245be0086&amp;utm_campaign=Referral_Invite&amp;utm_medium=Referral_Program&amp;utm_source=CopyPaste" target="_blank" rel="noopener">Digtailocean</a>进去注册，我选</p><p>择的是每个月5$的, 系统选用的是ubuntu 14.01 64位， 至此我们的服务器搞定。</p><p>首先我们在本地 【 Crt+Shift + T 】打开本地终端, 链接服务器 [ssh -t root@公网ip地址 -p 22]</p><p>首先我们修改服务器密码, 主要 默认密码会发送到你填写的邮箱，刚开始要输入两次密码， 有点变态 OK<br>修改号密码之后就登录成功了，接下来就是安装ss环境了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install python-gevent python-pip python-m2crypto python-wheel python-setuptools</span><br><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><p>安装好之后就是修改配置文件了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &apos;server&apos;: &apos;your ip&apos;,</span><br><span class="line">    &apos;server_port&apos;: 8083,</span><br><span class="line">    &apos;local_address&apos;: &apos;127.0.0.1&apos;,</span><br><span class="line">    &apos;local_port&apos;: 1080,</span><br><span class="line">    &apos;password&apos;: &apos;密码&apos;,</span><br><span class="line">    &apos;timeout&apos;: 300,</span><br><span class="line">    &apos;method&apos;: &apos;aes-256-cfb&apos;,</span><br><span class="line">    &apos;fast-open&apos;: false</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此位置,配置文件已搞定, 接下来该开启服务了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsols.json -d start</span><br></pre></td></tr></table></figure><p>搞定！</p><p>接下来，开始安装<a href="https://github.com/google/bbr" target="_blank" rel="noopener">BBR</a>谷歌的黑科技，服务端加速。这里由详细<a href="https://teddysun.com/489.html" target="_blank" rel="noopener">教程</a>。</p>]]></content>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习笔记之(四)webpack热更新</title>
      <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%9B%9B-webpack%E7%83%AD%E6%9B%B4%E6%96%B0.html"/>
      <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B-%E5%9B%9B-webpack%E7%83%AD%E6%9B%B4%E6%96%B0.html</url>
      <content type="html"><![CDATA[<p>1、Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)</p><p>2、页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端</p><p>3、客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash</p><p>4、修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端</p><p>5、客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档</p><p>6、hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。</p>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习笔记(三)webpack实际开发中的应用</title>
      <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-webpack%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
      <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-webpack%E5%AE%9E%E9%99%85%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html</url>
      <content type="html"><![CDATA[<p>现在我们来到我们的开发目录, 那么实际开发中吧我们的小技巧告诉大家</p><p>一、source map<br>在实际项目开发中，我们会常常遇到把几个文件(a.js, b.js, c.js)打包为一个bundle.js文件， 时常会遇到其中一个文件打包出错了,那么我们很难定位到错误位置，<br>为了更加容易地指认错误和警告， Javascript提供的source map功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。</p><p>二、自动化构建工具<br>webpack watch model<br>webpack dev server<br>webpack dev middleware</p><p>实时监控代码，一旦代码被修改将自动重新编译</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"script"</span>: &#123;</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"webpack --watch"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用webpack-dev-server<br>这个模块提供了一个简单的web服务,并且能实时重新加载<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-servre</span><br></pre></td></tr></table></figure></p><p>使用webpack-dev-middleware</p><p>他可以把webpack处理后的文件传递给一个服务器，也可以作为一个独立的模块使用.</p>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>webpack配置文件</title>
      <link href="/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html"/>
      <url>/webpack%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.html</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">     <span class="comment">// 入口文件</span></span><br><span class="line">entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line"><span class="comment">// 输出文件</span></span><br><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// css 样式加载</span></span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'style-loader'</span>,</span><br><span class="line">                    <span class="string">'css-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 图片加载</span></span><br><span class="line">                test: <span class="regexp">/\.(png|svg|jpg|gif)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'file-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 加载字体</span></span><br><span class="line">                test: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'file-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 加载数据</span></span><br><span class="line">                test: <span class="regexp">/\.(csv|tsv)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'css-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// xml文件</span></span><br><span class="line">                test: <span class="regexp">/\.xml$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    <span class="string">'xml-loader'</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习笔记之webpack配置篇</title>
      <link href="/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bwebpack%E9%85%8D%E7%BD%AE%E7%AF%87.html"/>
      <url>/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bwebpack%E9%85%8D%E7%BD%AE%E7%AF%87.html</url>
      <content type="html"><![CDATA[<p>webpack是现在前端一款很好的文件配置加载工具， 我们自已很轻松使用他构建我们的项目。</p><p>首先我们要在我们的工作环境安装webpack环境依赖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack --sava</span><br></pre></td></tr></table></figure><p>现在来到我们的项目下,新建文件webpack的配置文件webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.expres = &#123;</span><br><span class="line">    <span class="comment">// 要编译的入口文件</span></span><br><span class="line">    entry: <span class="string">'[name].js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">// 编译输出文件</span></span><br><span class="line">        filename: <span class="string">'name.js'</span>,</span><br><span class="line">        <span class="comment">// dist 是要输出的文件路径</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们来到package.json文件里面, 修改以下对应内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译命令</span></span><br><span class="line">script: &#123;</span><br><span class="line">    build: <span class="string">'webpack'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们回来命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>OK, 至此一个简单的webpack配置环境就算搭建完成了。</p>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>项目迁移</title>
      <link href="/%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB.html"/>
      <url>/%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB.html</url>
      <content type="html"><![CDATA[<p>之前的博客现在已经迁移到这块</p>]]></content>
      
      
    </entry>
    
  
  
</search>
